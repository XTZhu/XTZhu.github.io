---
title: java8的JVM持久代--何去何从？
date: 2019-02-23 22:05:58
tags: 
	- JVM
	- java8
---

> 原帖地址： https://blog.csdn.net/yechaodechuntian/article/details/40341975

# 基础知识

JVM只不过是运行在你系统上的另一个进程而已，这一切的魔法始于一个java命令。正如任何一个操作系统进程那样，JVM也需要内存来完成它的运行时操作。记住——JVM本身是硬件的一层软件抽象，在这之上才能够运行Java程序，也才有了我们所吹嘘的平台独立性以及WORA（一次编写，处处运行）。

## 快速过一遍JVM的内存结构

正如虚拟机规范所说的那样，JVM中的内存分为5个虚拟的区域。

- 堆
- 方法区（非堆）
- JVM栈
- 本地栈
- PC寄存器

## 堆

- 你的Java程序中所分配的每一个对象都需要存储在内存里。堆是这些实例化的对象所存储的地方。是的——都怪new操作符，是它把你的Java堆都占满了的！
- 它由所有线程共享
- 当堆耗尽的时候，JVM会抛出java.lang.OutOfMemoryError 异常
- 堆的大小可以通过JVM选项-Xms和-Xmx来进行调整

## 堆被分为：

- Eden区 —— 新对象或者生命周期很短的对象会存储在这个区域中，这个区的大小可以通过-XX:NewSize和-XX:MaxNewSize参数来调整。新生代GC（垃圾回收器）会清理这一区域。
- Survivor区 —— 那些历经了Eden区的垃圾回收仍能存活下来的依旧存在引用的对象会待在这个区域。这个区的大小可以由JVM参数-XX:SurvivorRatio来进行调节。
- 老年代 —— 那些在历经了Eden区和Survivor区的多次GC后仍然存活下来的对象（当然了，是拜那些挥之不去的引用所赐）会存储在这个区里。这个区会由一个特殊的垃圾回收器来负责。年老代中的对象的回收是由老年代的GC（major GC）来进行的。

##  方法区

- 也被称为非堆区域（在HotSpot JVM的实现当中）
- 它被分为两个主要的子区域

## 持久代
这个区域会存储包括类定义，结构，字段，方法（数据及代码）以及常量在内的类相关数据。它可以通过-XX:PermSize及-XX:MaxPermSize来进行调节。如果它的空间用完了，会导致java.lang.OutOfMemoryError: PermGen space的异常。

## 代码缓存

这个缓存区域是用来存储编译后的代码。编译后的代码就是本地代码（硬件相关的），它是由JIT（Just In Time)编译器生成的，这个编译器是Oracle HotSpot JVM所特有的。

# JVM栈

- 和Java类中的方法密切相关
- 它会存储局部变量以及方法调用的中间结果及返回值
- Java中的每个线程都有自己专属的栈，这个栈是别的线程无法访问的。
- 可以通过JVM选项-Xss来进行调整

# 本地栈

- 用于本地方法（非Java代码）
- 按线程分配

# PC寄存器

- 特定线程的程序计数器
- 包含JVM正在执行的指令的地址（如果是本地方法的话它的值则未定义）

好吧，这就是JVM内存分区的基础知识了。现在再说说持久代这个话题吧。

## 那么持久代上哪去了？

事实上，持久代已经被彻底删除了，取代它的是另一个内存区域也被称为元空间。

### 元空间 —— 快速入门

- 它是本地堆内存中的一部分
- 它可以通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize来进行调整
- 当到达XX:MetaspaceSize所指定的阈值后会开始进行清理该区域
- 如果本地空间的内存用尽了会收到java.lang.OutOfMemoryError: Metadata space的错误信息。
- 和持久代相关的JVM参数-XX:PermSize及-XX:MaxPermSize将会被忽略掉。

当然了，这只是冰山一角。想要更深入地了解JVM，最好的资料莫过于它自己的虚拟机规范了！