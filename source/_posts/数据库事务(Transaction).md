---
title: 数据库事务(Transaction)
date: 2019-04-14 18:06:20
tags: 
	- 数据库
	- MySQL/Orcale
	- 事务 
---

# 什么是事务？

- *Transaction*
- >数据库事务(transaction)就是一组SQL语句，这组SQL语句是一个**逻辑工作单元**(logical unit of work). 可以认为事务就是一组不可分割的SQL语句，其结果应该作为整体永久性地修改数据库的内容，或者作为整体取消对数据库的修改。   			     
 >> (精通Oracle Database 12c SQL&PL/SQL编程 269)

- 数据库事务的一个例子就是将钱从一个银行账户转到另一个银行账户中去。此时通常包含两个操作：一条UPDATE语句负责从一个银行账户的总额中减去一定的钱数，另一条UPDATE语句负责向另一个银行账户中增加相应的钱数。减少和增加这两个操作必须永久性的记录到数据库中，否则钱就会丢失。如果钱的转账有问题，就必须同时取消减少和增加 这两个操作。这个简单的例子只使用了两条UPDATE语句，然而事务可以包含多条INSERT、UPDATE、和DELETE语句。

- 换言之，事务可以概括为：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)

- 一个完整的业务需要批量的DML(`insert`、`update`、`delete`)语句共同联合完成
- 事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同


## 事务的提交和回滚

要永久性的记录事务中的SQL语句的结果，需要执行`COMMIT`语句。
要取消SQL语句的结果，需要执行`ROLLBACK`语句，将所有行重新设置为原始状态。

## 事务的开始与结束

事务是用来分割SQL语句的逻辑工作单元。事务既有起点，也有终点；
**当下列事件之一发生时，事务就开始了：**
- 连接到数据库，并执行一条DML语句(INSERT、UPDATE、或DELETE)。注意，`MERGE`也是DML语句。
- 前一个事务结束后，又输入了另一条DML语句。

**当下列事件之一发生时，事务就结束了：**
- 执行`COMMIT`或`ROLLBACK`语句。
- 执行一条`DDL`语句，例如`CREATE TABLE`语句；在这种情况下，会自动执行COMMIT语句。
- 执行一条`DCL`语句，例如`GRANT`语句；在这种情况下会自动执行COMMIT语句。
> 注意： 自动的*COMMIT*语句被加在*DDL*和*DCL*语句前，因此即使*DDL*和*DCL*语句没有成功，也会执行*COMMIT*语句。
- 断开数据库的连接。断开连接时会执行`COMMIT`语句，但是当意外中止(如程序崩溃)时，会自动执行`ROLLBACK`语句。这适用于任何可能访问数据库的程序。例如，如果编写了一个可以访问数据库的Java程序，而这个程序崩溃了，就会自动执行ROLLBACK语句。
- 执行了一条`DML`语句，该语句却失败了；在这种情况下，会自动为这条无效的DML语句执行ROLLBACK语句。

**提示 ：**
	*不显式提交或回滚被认为是不好的编程习惯，因此确保在每个事务后面都要执行COMMIT或者ROLLBACK语句。*

## 保存点

在事务中的任何地方都可以设置**保存点(savepoint)**，这样可以将修改回滚到保存点处。如果有一个很大的事务，这将非常有用，因为这样如果在保存点后进行了误操作，并不需要将整个事务一直回滚到最开头。但是保存点不能肆意乱用；最好是重新调整一下事务的结构，将其转换为较小的事务。

## 事务与数据库底层数据

在事务进行过程中，未结束之前，DML语句是不会更改底层数据，只是将历史操作记录一下，在内存中完成记录。只有在事物结束的时候，而且是成功的结束的时候，才会修改底层硬盘文件中的数据。

# 事务的ACID特性

在前面我们将事务定义为逻辑工作单元，即一组相关的SQL语句，它们要么作为一个单位被**提交**，要么作为一个单位被**回滚**。数据库理论对事务采用了更严格的定义，说明事务有4个基本的特征，称为ACID特性。

- **原子性(Atomic)：**    事务是原子的，这就是说事务中包含的所有SQL语句组成一个工作单元。
- **一致性(Consist)：**    事务必须确保数据的状态保持一致，这就是说事务开始时，数据库的状态是一致的；在事务结束后，数据库的状态也必须是一致的。
- **隔离性(Isolated)：**  多个事务可以独立运行，而不会彼此产生影响。
- **持久性(Durable)：**    一旦事务被提交之后，数据库的变化就会被永久保存下来，即使运行数据库的软件的机器后来崩溃也是如此。

# 并发事务
Oracle数据库软件支持多个用户同时与数据库进行交互，每个用户都可以同时运行自己的事务。这种事务就称为并发事务(concurrent transaction)。

如果用户同时运行多个事务，而这些事务都对同一个表产生影响，那么这些事务的影响都是独立的，直到执行一条COMMIT语句时才会彼此产生影响。

下面两个事务T1和T2都会访问customers表，看下面这个例子展示事务的隔离性：

		1. T1和T2分别执行SELECT语句，检索customers表的所有行
		2. T1执行INSERT语句，向customers表中插入数据，但此时T1并不执行COMMIT语句。
		3. T2再执行一条SELECT语句，检索结果和步骤1中相同，T2没有“看到”T1在步骤2中插入的新行。
		4. T1最后执行COMMIT语句，永久性的保存了插入的新行。
		5. T2执行一条SELECT语句，最终看到了T1插入的新行。

以上过程可以归纳如下： 直到T1提交自己对数据库所做的修改之后，T2才能看得到T1对数据库所做的修改。这是事务间隔离性的默认级别。***隔离性级别可以修改***

|事务T1|事务T2|
|--|--|
|(1) **SELECT * FROM customers;**|(2) **SELECT * FROM customers;**|
|(3) **INSERT INTO customers(xx, xx, xx) VALUES (XX, XX, XX);**||
|(4)**UPDATE customers SET xx = XX WHERE customer_xx = X;**||
|(5) **SELECT * FROM customers;**返回的结果集中包含新插入的行和修改后的行|(6) **SELECT * FROM customers;**返回的结果集中不包含事务T1插入和修改后的行，而是在步骤2中检索出来的原来的行|
|(7) **COMMIT;**提交新行和所做的修改||
||(8)**SELECT * FROM customers;** 返回的结果集中包含T1在步骤3和步骤4中插入和修改的行 |

# 事务锁

要实现并发事务，Oracle 数据库软件必须确保表中的数据一直有效。这可以通过**锁(lock)**来实现。下面这个例子：事务T1和T2都试图修改customers表中的顾客#1：
1. T1执行一条UPDATE语句，修改顾客#1,但是T1并没有执行COMMIT语句。此时就称T1对该行“加锁”了。
1. T2也试图执行一条UPDATE语句，修改顾客#1，但是由于该行早已被T1加锁了，因此T2现在就不能获得该行的锁。T2的UPDATE语句必须一直等待，直到T1结束并释放该行上的锁为止。
1. T1执行COMMIT语句并结束，从而释放该行上的锁。
1. T2获得该行上的锁，并执行UPDATE语句。T2在获得该行上的锁后一直持有，直到T2结束为止。

以上过程概括为： 当一个事务已经拥有某一行上的锁时，另外一个事务不能获得该行上的锁。

> **注意：**
理解默认加锁机制的最简单方法如下：`读程序(reader)`不会阻碍`读程序`；`写程序(writer)`不会阻碍`读程序`；只有在试图对相同的行进行修改时，`写程序`才会阻碍`写程序`。

# 事务的隔离级别

在SQL的标准中，定义了四种隔离级别。每一种级别都规定了，在一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。低级别的隔离可以执行更高级别的并发，性能好，但是会出现脏读和幻读的现象。首先，我们从三个基础的概念说起：

- **脏读（dirty read）：**两个事务，一个事务读取到了另一个事务未提交的数据，这便是脏读。

- **幻读（phantom read）：**两个事务，事务A与事务B，事务A在自己执行的过程中，执行了两次相同查询，第一次查询事务B未提交，第二次查询事务B已提交，从而造成两次查询结果不一样，这个其实被称为不可重复读；如果事务B是一个会影响查询结果的insert操作，则好像新多出来的行像幻觉一样，因此被称为幻读。其他事务的提交会影响在同一个事务中的重复查询结果。

- **不可重复读（nonrepeatable read）：**两个事务，事务T1读取一行，紧接着事务T2修改了T1刚才读取的那一行的内容。然后T1又读取了这一行，发现它与刚才读取的结果不同了。这种现象称为“不可重复读”，因为T1原来读取的那一行已经发生了变化。

下面简单描述一下SQL中定义的四种标准隔离级别：

1. **READ UNCOMMITTED (未提交读) ：**
- 隔离级别：0. 
- 事物A和事物B，事物A未提交的数据，事物B可以读取到
- 可以读取未提交的记录。
- 会出现脏读。
- 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别

1. **READ COMMITTED (提交读) ：**
- 隔离级别：1. 
- 事物A和事物B，事物A提交的数据，事物B才能读取到
- 事务中只能看到已提交的修改。
- 不可重复读，会出现幻读。（在InnoDB中，会加行所，但是不会加间隙锁）
- 该隔离级别是大多数数据库系统(如Oracle)的默认隔离级别，但是MySQL的则是RR。

1. **REPEATABLE READ (可重复读) ：**
- 隔离级别：2. 
- 事务A和事务B，事务A提交之后的数据，事务B读取不到
- 事务B是可重复读取数据
- 换句话说，对方提交之后的数据，我还是读取不到
- MySQL默认级别
- 在InnoDB中是这样的：RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，因此不存在幻读现象。但是标准的RR只能保证在同一事务中多次读取同样记录的结果是一致的，而无法解决幻读问题。
- InnoDB的幻读解决是依靠MVCC的实现机制做到的。

1. **SERIALIZABLE （可串行化）：**
- 隔离级别：3. 
- 事务A和事务B，事务A在操作数据库时，事务B只能排队等待
- 这种隔离级别很少使用，吞吐量太低，用户体验差
- 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发
- 该隔离级别会在读取的每一行数据上都加上锁，退化为基于锁的并发控制，即LBCC。
 　　
 >需要注意的是，MVCC只在RC和RR两个隔离级别下工作，其他两个隔离级别都和MVCC不兼容。

## 设置事务隔离级别

### 方式一

- 可以在my.ini文件中使用transaction-isolation选项来设置服务器的缺省事务隔离级别。
- 该选项值可以是
		– READ-UNCOMMITTED
		– READ-COMMITTED
		– REPEATABLE-READ
		– SERIALIZABLE

		•   例如：
		[mysqld]
		transaction-isolation = READ-COMMITTED

### 方式二

- 通过命令动态设置隔离级别
	- 隔离级别也可以在运行的服务器中动态设置，应使用SET TRANSACTION ISOLATION LEVEL语句。
	- 其语法模式为：
			SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL <isolation-level>
			其中的<isolation-level>可以是：
			–   READ UNCOMMITTED
			–   READ COMMITTED
			–   REPEATABLE READ
			–   SERIALIZABLE
			•   例如： SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

## 隔离级别的作用范围

	•   事务隔离级别的作用范围分为两种： 
	–   全局级：对所有的会话有效 
	–   会话级：只对当前的会话有效 
	•   例如，设置会话级隔离级别为READ COMMITTED ：
	mysql> SET TRANSACTION ISOLATION LEVEL READ COMMITTED；
	或：
	mysql> SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED；
	•   设置全局级隔离级别为READ COMMITTED ： 
	mysql> SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED；

## 查看隔离级别

	select @@global.tx_isolation, @@tx_isolation 和 show variables like '%isolation%'


> 关于事务隔离级别，锁，以及并发控制与加锁分析，可参考的技术博客
	[事务隔离级别](https://xtzhu.github.io/2019/03/20/%E9%9D%A2%E8%AF%95%E9%A2%9870-80/#20)
	[并发控制与加锁分析](https://www.cnblogs.com/yelbosh/p/5813865.html)
	[MySQL 加锁处理分析](https://note.youdao.com/ynoteshare1/index.html?id=daad612052801c77458ee3fa5b366e20&type=note&from=timeline&isappinstalled=0#/)

> 引用的技术博客
	[MySQL——事务(Transaction)详解](https://blog.csdn.net/w_linux/article/details/79666086)
