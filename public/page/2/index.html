<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://XTZhu.github.io').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="learnLess">
<meta property="og:type" content="website">
<meta property="og:title" content="PPPig&#39;s TreeHole">
<meta property="og:url" content="http:&#x2F;&#x2F;xtzhu.github.io&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="PPPig&#39;s TreeHole">
<meta property="og:description" content="learnLess">
<meta property="article:author" content="XTZhu">
<meta property="article:tag" content="XTZhu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xtzhu.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>PPPig's TreeHole</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">PPPig's TreeHole</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">在人生的道路上，人是自由的</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xtzhu.github.io/2019/04/18/Ajax%E8%B7%A8%E5%9F%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XTZhu">
      <meta itemprop="description" content="learnLess">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PPPig's TreeHole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/18/Ajax%E8%B7%A8%E5%9F%9F/" class="post-title-link" itemprop="url">Ajax跨域（转载）</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-04-18 22:12:57 / Modified: 23:23:27" itemprop="dateCreated datePublished" datetime="2019-04-18T22:12:57+08:00">2019-04-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>转载自<br>    <a href="https://segmentfault.com/a/1190000012469713" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012469713</a><br>    <a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a><br>    <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
</blockquote>
<h1 id="什么是同源政策？"><a href="#什么是同源政策？" class="headerlink" title="什么是同源政策？"></a>什么是同源政策？</h1><p>说起跨域，就必须先了解“同源政策”。浏览器安全的基石是”同源政策”（same-origin policy）。很多开发者都知道这一点，但了解得不全面。</p>
<h2 id="同源政策的含义"><a href="#同源政策的含义" class="headerlink" title="同源政策的含义"></a>同源政策的含义</h2><p>1995年，<code>同源政策</code>由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>
<p>最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓<strong>同源</strong>指的是”三个相同”。</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略）。它的同源情况如下。</p>
<pre><code>- http://www.example.com/dir2/other.html：同源
- http://example.com/dir/other.html：不同源（域名不同）
- http://v2.www.example.com/dir/other.html：不同源（域名不同）
- http://www.example.com:81/dir/other.html：不同源（端口不同）</code></pre><h2 id="同源政策的目的"><a href="#同源政策的目的" class="headerlink" title="同源政策的目的"></a>同源政策的目的</h2><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？</p>
<p>很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<p>由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<h2 id="同源政策的限制范围"><a href="#同源政策的限制范围" class="headerlink" title="同源政策的限制范围"></a>同源政策的限制范围</h2><p>随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<p>（1） Cookie、LocalStorage 和 IndexDB 无法读取。<br>（2） DOM 无法获得。<br>（3） AJAX 请求不能发送。</p>
<p>在这里我们主要讨论AJAX的跨域问题。</p>
<h1 id="AJAX的跨域"><a href="#AJAX的跨域" class="headerlink" title="AJAX的跨域"></a>AJAX的跨域</h1><p>同源政策规定，AJAX请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
<h2 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h2><p>(现在已经几乎不会再使用JSONP了，所以JSONP了解下即可)</p>
<p>jsonp解决跨域问题是一个比较古老的方案(实际中不推荐使用),这里做简单介绍(实际项目中如果要使用JSONP,一般会使用JQ等对JSONP进行了封装的类库来进行ajax请求)</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>JSONP之所以能够用来解决跨域方案,主要是因为<code>&lt;script&gt;</code>脚本拥有跨域能力,而JSONP正是利用这一点来实现。具体原理如图</p>
<p><img src="https://raw.githubusercontent.com/XTZhu/image/master/blog/20190418-1_articlex.png" alt="JSONP"></p>
<h3 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h3><p>JSONP的实现步骤大致如下</p>
<ul>
<li>客户端网页网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  script.setAttribute(<span class="string">"type"</span>,<span class="string">"text/javascript"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  script.src = src;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  addScriptTag(<span class="string">'http://example.com/ip?callback=foo'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">data</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">console</span>.log(<span class="string">'response data: '</span> + <span class="built_in">JSON</span>.stringify(data));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<p>请求时,接口地址是作为构建出的脚本标签的src的,这样,当脚本标签构建出来时,最终的src是接口返回的内容</p>
<ul>
<li><p>服务端对应的接口在返回参数外面添加函数包裹层</p>
<p>  foo({</p>
<pre><code>&quot;test&quot;: &quot;testData&quot;</code></pre><p>  }); </p>
</li>
<li><p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。</p>
</li>
</ul>
<p>注意,一般的JSONP接口和普通接口返回数据是有区别的,所以接口如果要做JSONO兼容,需要进行判断是否有对应callback关键字参数,如果有则是JSONP请求,返回JSONP数据,否则返回普通数据</p>
<blockquote>
<p><strong>使用注意:</strong> 基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了(所以如今它也基本被淘汰了)</p>
</blockquote>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的WebSocket请求的头信息</p>
<pre><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com</code></pre><p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<pre><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat</code></pre><h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能同源使用的限制。</p>
<h3 id="CORS简介"><a href="#CORS简介" class="headerlink" title="CORS简介"></a>CORS简介</h3><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<p>基本上目前所有的浏览器都实现了CORS标准,其实目前几乎所有的浏览器ajax请求都是基于CORS机制的,只不过可能平时前端开发人员并不关心而已(所以说其实现在CORS解决方案主要是考虑后台该如何实现的问题)。</p>
<p>这里也整理了一个实现原理图(简化版)</p>
<p><img src="https://raw.githubusercontent.com/XTZhu/image/master/blog/20190418-2_articlex.png" alt="CORS"></p>
<h3 id="如何判断是否是简单请求"><a href="#如何判断是否是简单请求" class="headerlink" title="如何判断是否是简单请求?"></a>如何判断是否是简单请求?</h3><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求</p>
<p>（1) 请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/- form-data、text/plain</li>
</ul>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<p><em>待续。。</em></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xtzhu.github.io/2019/04/16/java%E5%88%B0%E5%BA%95%E6%98%AF%E8%A7%A3%E9%87%8A%E6%80%A7%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XTZhu">
      <meta itemprop="description" content="learnLess">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PPPig's TreeHole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/16/java%E5%88%B0%E5%BA%95%E6%98%AF%E8%A7%A3%E9%87%8A%E6%80%A7%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%9F/" class="post-title-link" itemprop="url">java到底是解释性语言还是编译型语言？</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-04-16 22:34:04 / Modified: 22:37:19" itemprop="dateCreated datePublished" datetime="2019-04-16T22:34:04+08:00">2019-04-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Java这个语言很非凡。<br>一、你可以说它是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。 </p>
<p>二、你可以说它是解释型的。因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释的了。</p>
<p>三、但是，现在的JVM为了效率，都有一些JIT优化。它又会把.class的二进制代码编译为本地的代码直接运行，所以，又是编译的。</p>
<p>像C、C++ 他们经过一次编译之后直接可以编译成操作系统了解的类型，可以直接执行的 所以他们是编译型的语言。没有经过第二次的处理 而Java不一样他首先由编译器编译成.class类型的文件，这个是java自己类型的文件 然后在通过虚拟机(JVM)从.class文件中读一行解释执行一行，所以他是解释型的语言，而由于java对于多种不同的操作系统有不同的JVM所以 Java实现了真正意义上的跨平台！ </p>
<p>请观看下面两张图 了解一下Java的虚拟机机制：</p>
<p>(1)java语言的编译–&gt;解释—&gt;执行过程 </p>
<p><img src="https://raw.githubusercontent.com/XTZhu/image/master/blog/20170519090738244.png" alt=""></p>
<p>(2)java的虚拟机 </p>
<p><img src="https://raw.githubusercontent.com/XTZhu/image/master/blog/20170519090836650.png" alt=""></p>
<p>今天听到同事在讨论java是哪种类型的语言（编译型、解释型），以前稍微有些接触，但是概念比较模糊，为了不至于让别人的思想左右自己，所以查了些资料，找到了很多热心网友给出的答案，终于有些明白。这里先给出编译型语言和解释型语言的定义。 </p>
<p>定义：<br>编译型语言：把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。<br>解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！</p>
<p>区别：<br>编译型语言，执行速度快、效率高；依靠编译器、跨平台性差些。<br>解释型语言，执行速度慢、效率低；依靠解释器、跨平台性好。 </p>
<p>个人认为，java是解释型的语言，因为虽然java也需要编译，编译成.class文件，但是并不是机器可以识别的语言，而是字节码，最终还是需要 jvm的解释，才能在各个平台执行，这同时也是java跨平台的原因。所以可是说java即是编译型的，也是解释型，但是假如非要归类的话，从概念上的定义，恐怕java应该归到解释型的语言中。</p>
<p>附：<br>编译型的语言包括：C、C++、Delphi、Pascal、Fortran<br>解释型的语言包括：Java、Basic、javascript</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xtzhu.github.io/2019/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)--%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XTZhu">
      <meta itemprop="description" content="learnLess">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PPPig's TreeHole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)--%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">设计模式(1)--简单工厂模式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-14 22:46:20" itemprop="dateCreated datePublished" datetime="2019-04-14T22:46:20+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-04-16 22:32:23" itemprop="dateModified" datetime="2019-04-16T22:32:23+08:00">2019-04-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在Mybatis中比如SqlSessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。</p>
<p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p><img src="https://raw.githubusercontent.com/XTZhu/image/master/blog/idea64_pNfdoCW73P.png" alt=""></p>
<p>SqlSession可以认为是一个<a href="https://mp.weixin.qq.com/s/EzkQHVmW2deBXlmj9jIOAg" target="_blank" rel="noopener">Mybatis</a>工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。从 0 开始手写一个 Mybatis 框架，这个我推荐你看下。</p>
<p><img src="https://raw.githubusercontent.com/XTZhu/image/master/blog/idea64_OWJhevdvRs.png" alt=""></p>
<p>可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。</p>
<p>在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SqlSession <span class="title">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> autoCommit)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   Transaction tx = <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">final</span> Environment environment = configuration.getEnvironment();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">final</span> TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">     tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">final</span> Executor executor = configuration.newExecutor(tx, execType);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSession(configuration, executor, autoCommit);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">     closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                 <span class="comment">// close()</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error opening session.  Cause: "</span> + e, e);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">     ErrorContext.instance().reset();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr></table></figure>

<p> 这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始化TransactionFactory获得一个Transaction对象，然后通过Transaction获取一个Executor对象，最后通过configuration、Executor、是否autoCommit三个参数构建了SqlSession。</p>
<p> 在这里其实也可以看到端倪，SqlSession的执行，其实是委托给对应的Executor来进行的。</p>
<p> 而对于LogFactory，它的实现代码:</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// disable construction</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> getLog(aClass.getName());</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p> 这里有个特别的地方，是Log变量的的类型是Constructor&lt;? extends Log&gt;，也就是说该工厂生产的不只是一个产品，而是具有Log公共接口的一系列产品，比如Log4jImpl、Slf4jImpl等很多具体的Log。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xtzhu.github.io/2019/04/14/%E4%B8%80%E4%BA%9B%E6%84%9F%E8%A7%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XTZhu">
      <meta itemprop="description" content="learnLess">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PPPig's TreeHole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/14/%E4%B8%80%E4%BA%9B%E6%84%9F%E8%A7%A6/" class="post-title-link" itemprop="url">一些感触</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-04-14 22:44:20 / Modified: 23:48:56" itemprop="dateCreated datePublished" datetime="2019-04-14T22:44:20+08:00">2019-04-14</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从毕业到现在，工作也快1年半了，这一年来变化真是很大。当初大四最后一学期的补Java基础，看框架视频，做了半本书的笔记，现在也不知道在哪了；从找实习，找工作时的迷茫到现在的可以独立开发一些小项目，从无到有，更让自己觉得要学的东西太多，也在后悔大学没有好好努力，没有早点认识到方向的重要性。</p>
<p>去年的3月份，带着妹妹和好友Y去长沙旅游，Y君从山东飞到长沙，我们坐高铁到火车站，当时天色已晚，我们从火车站坐的士去机场接机。司机师傅是当地人，车程大约一个小时左右，我用我蹩脚的武汉话和司机师傅拉起家常。当时说的琐事已经记不清了，只记得他说:人在年轻的时候最容易迷茫，不知道自己到底要做什么，好多人都是在迷迷茫茫中，青春就过去了。做着自己不喜欢的事，到头来竹篮打水。最好做好计划，但是必须要长远，五年也行，十年也行。可以做一年的的计划，但是这些事情都必须很具体。下车时，他聊得投机，看我们也是学生，要少收一点，我还是按原价给了他。之后妹妹说起在的士上的事情，只说我在连连点头，满口嗯嗯。我是很赞同他说的话，除开我是一个很没有安全感的人以外，我这个人对未来也没有太多的想法，回想从前，每个时期都会觉得之前的日子完全是浪费。学校的生涯，初中、高中、大学，到现在，每一步都是随性走过来的。大多数时间竟然都是在焦虑中度过，如果懂的再多一点，面对事情的时候就会更有把握一点。可惜，时间只能一直向前走。</p>
<p>这世界上唯一不变的事情就是永远在变。事情是如此，人与人也是如此，期望没有经过付出的回报是毫无意义的。人与人之间的关系总是很微妙，好友和亲人有时可以混为一谈，更多的时候，家人，是唯一不向你索取却一直给予的人。人总是能从别人的身上学到东西。见人说人话，见鬼说鬼话；这是上辈语重心长说出来的，虽然当时他已经喝醉了，不过半辈子人生和社会经验融成的这句话，确实也让我感觉到一点其中的深意。我不喜欢一直抓着一个东西不放，如果一直耿耿于怀，心理生理上都会感觉憋屈，那些走过的坑，踩过的泥潭，都值得感谢，感谢让我体会到了这种感觉，不会再来一次的感觉。去年给自己定了一个备忘录，时间是一年后，内容是: 你有一番作为了吗？现在看来，和自己的想法差距甚大，反观现在，依然是随性，不过焦虑少了一些，改变是有的，不过前路漫漫。计划还是没有完成，一年前我会想到现在是怎么样吗？我现在又能想到一年后会是怎样吗？五年呢，十年呢？没有想法，只能从具体的事情开始做起。短期计划尚不能保证完全如意，何况长远，只能慢慢靠近。</p>
<p>希望一直开心下去，每个月读一本工具书，一本著作；坚持学英语，主要是记单词；坚持锻炼身体，可以跑步，可以散步，也可以仰卧起坐，俯卧撑，什么都行，但是要坚持；把想学的技术栈都弄懂，这样可以少问一点，少迷茫一点，懂得越多，越要精通一门或多门，可以学感兴趣的，爬虫、大数据；算法和数据结构是很重要的东西，设计模式，存储过程等等；爱好，还有什么呢，口琴很久没有碰过了，慢慢捡起来吧；自制力是现在最欠缺的东西，不过好像渐渐开始变好了，是因为对别的事情没有兴趣了？不知道是好事还是坏事。希望可以一直做自己喜欢的事情，希望变成更好的人，希望未来的事情都会变得简单，希望可以有属于自己的一块地方，希望。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xtzhu.github.io/2019/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1(Transaction)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XTZhu">
      <meta itemprop="description" content="learnLess">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PPPig's TreeHole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1(Transaction)/" class="post-title-link" itemprop="url">数据库事务(Transaction)</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-14 18:06:20" itemprop="dateCreated datePublished" datetime="2019-04-14T18:06:20+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-04-16 21:47:29" itemprop="dateModified" datetime="2019-04-16T21:47:29+08:00">2019-04-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h1><ul>
<li><p><em>Transaction</em></p>
</li>
<li><blockquote>
<p>数据库事务(transaction)就是一组SQL语句，这组SQL语句是一个<strong>逻辑工作单元</strong>(logical unit of work). 可以认为事务就是一组不可分割的SQL语句，其结果应该作为整体永久性地修改数据库的内容，或者作为整体取消对数据库的修改。                    </p>
<blockquote>
<p>(精通Oracle Database 12c SQL&amp;PL/SQL编程 269)</p>
</blockquote>
</blockquote>
</li>
<li><p>数据库事务的一个例子就是将钱从一个银行账户转到另一个银行账户中去。此时通常包含两个操作：一条UPDATE语句负责从一个银行账户的总额中减去一定的钱数，另一条UPDATE语句负责向另一个银行账户中增加相应的钱数。减少和增加这两个操作必须永久性的记录到数据库中，否则钱就会丢失。如果钱的转账有问题，就必须同时取消减少和增加 这两个操作。这个简单的例子只使用了两条UPDATE语句，然而事务可以包含多条INSERT、UPDATE、和DELETE语句。</p>
</li>
<li><p>换言之，事务可以概括为：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元)</p>
</li>
<li><p>一个完整的业务需要批量的DML(<code>insert</code>、<code>update</code>、<code>delete</code>)语句共同联合完成</p>
</li>
<li><p>事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同</p>
</li>
</ul>
<h2 id="事务的提交和回滚"><a href="#事务的提交和回滚" class="headerlink" title="事务的提交和回滚"></a>事务的提交和回滚</h2><p>要永久性的记录事务中的SQL语句的结果，需要执行<code>COMMIT</code>语句。<br>要取消SQL语句的结果，需要执行<code>ROLLBACK</code>语句，将所有行重新设置为原始状态。</p>
<h2 id="事务的开始与结束"><a href="#事务的开始与结束" class="headerlink" title="事务的开始与结束"></a>事务的开始与结束</h2><p>事务是用来分割SQL语句的逻辑工作单元。事务既有起点，也有终点；<br><strong>当下列事件之一发生时，事务就开始了：</strong></p>
<ul>
<li>连接到数据库，并执行一条DML语句(INSERT、UPDATE、或DELETE)。注意，<code>MERGE</code>也是DML语句。</li>
<li>前一个事务结束后，又输入了另一条DML语句。</li>
</ul>
<p><strong>当下列事件之一发生时，事务就结束了：</strong></p>
<ul>
<li>执行<code>COMMIT</code>或<code>ROLLBACK</code>语句。</li>
<li>执行一条<code>DDL</code>语句，例如<code>CREATE TABLE</code>语句；在这种情况下，会自动执行COMMIT语句。</li>
<li>执行一条<code>DCL</code>语句，例如<code>GRANT</code>语句；在这种情况下会自动执行COMMIT语句。<blockquote>
<p>注意： 自动的<em>COMMIT</em>语句被加在<em>DDL</em>和<em>DCL</em>语句前，因此即使<em>DDL</em>和<em>DCL</em>语句没有成功，也会执行<em>COMMIT</em>语句。</p>
</blockquote>
</li>
<li>断开数据库的连接。断开连接时会执行<code>COMMIT</code>语句，但是当意外中止(如程序崩溃)时，会自动执行<code>ROLLBACK</code>语句。这适用于任何可能访问数据库的程序。例如，如果编写了一个可以访问数据库的Java程序，而这个程序崩溃了，就会自动执行ROLLBACK语句。</li>
<li>执行了一条<code>DML</code>语句，该语句却失败了；在这种情况下，会自动为这条无效的DML语句执行ROLLBACK语句。</li>
</ul>
<p><strong>提示 ：</strong><br>    <em>不显式提交或回滚被认为是不好的编程习惯，因此确保在每个事务后面都要执行COMMIT或者ROLLBACK语句。</em></p>
<h2 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h2><p>在事务中的任何地方都可以设置<strong>保存点(savepoint)</strong>，这样可以将修改回滚到保存点处。如果有一个很大的事务，这将非常有用，因为这样如果在保存点后进行了误操作，并不需要将整个事务一直回滚到最开头。但是保存点不能肆意乱用；最好是重新调整一下事务的结构，将其转换为较小的事务。</p>
<h2 id="事务与数据库底层数据"><a href="#事务与数据库底层数据" class="headerlink" title="事务与数据库底层数据"></a>事务与数据库底层数据</h2><p>在事务进行过程中，未结束之前，DML语句是不会更改底层数据，只是将历史操作记录一下，在内存中完成记录。只有在事物结束的时候，而且是成功的结束的时候，才会修改底层硬盘文件中的数据。</p>
<h1 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h1><p>在前面我们将事务定义为逻辑工作单元，即一组相关的SQL语句，它们要么作为一个单位被<strong>提交</strong>，要么作为一个单位被<strong>回滚</strong>。数据库理论对事务采用了更严格的定义，说明事务有4个基本的特征，称为ACID特性。</p>
<ul>
<li><strong>原子性(Atomic)：</strong>    事务是原子的，这就是说事务中包含的所有SQL语句组成一个工作单元。</li>
<li><strong>一致性(Consist)：</strong>    事务必须确保数据的状态保持一致，这就是说事务开始时，数据库的状态是一致的；在事务结束后，数据库的状态也必须是一致的。</li>
<li><strong>隔离性(Isolated)：</strong>  多个事务可以独立运行，而不会彼此产生影响。</li>
<li><strong>持久性(Durable)：</strong>    一旦事务被提交之后，数据库的变化就会被永久保存下来，即使运行数据库的软件的机器后来崩溃也是如此。</li>
</ul>
<h1 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h1><p>Oracle数据库软件支持多个用户同时与数据库进行交互，每个用户都可以同时运行自己的事务。这种事务就称为并发事务(concurrent transaction)。</p>
<p>如果用户同时运行多个事务，而这些事务都对同一个表产生影响，那么这些事务的影响都是独立的，直到执行一条COMMIT语句时才会彼此产生影响。</p>
<p>下面两个事务T1和T2都会访问customers表，看下面这个例子展示事务的隔离性：</p>
<pre><code>1. T1和T2分别执行SELECT语句，检索customers表的所有行
2. T1执行INSERT语句，向customers表中插入数据，但此时T1并不执行COMMIT语句。
3. T2再执行一条SELECT语句，检索结果和步骤1中相同，T2没有“看到”T1在步骤2中插入的新行。
4. T1最后执行COMMIT语句，永久性的保存了插入的新行。
5. T2执行一条SELECT语句，最终看到了T1插入的新行。</code></pre><p>以上过程可以归纳如下： 直到T1提交自己对数据库所做的修改之后，T2才能看得到T1对数据库所做的修改。这是事务间隔离性的默认级别。<strong><em>隔离性级别可以修改</em></strong></p>
<table>
<thead>
<tr>
<th>事务T1</th>
<th>事务T2</th>
</tr>
</thead>
<tbody><tr>
<td>(1) <strong>SELECT * FROM customers;</strong></td>
<td>(2) <strong>SELECT * FROM customers;</strong></td>
</tr>
<tr>
<td>(3) <strong>INSERT INTO customers(xx, xx, xx) VALUES (XX, XX, XX);</strong></td>
<td></td>
</tr>
<tr>
<td>(4)<strong>UPDATE customers SET xx = XX WHERE customer_xx = X;</strong></td>
<td></td>
</tr>
<tr>
<td>(5) <strong>SELECT * FROM customers;</strong>返回的结果集中包含新插入的行和修改后的行</td>
<td>(6) <strong>SELECT * FROM customers;</strong>返回的结果集中不包含事务T1插入和修改后的行，而是在步骤2中检索出来的原来的行</td>
</tr>
<tr>
<td>(7) <strong>COMMIT;</strong>提交新行和所做的修改</td>
<td></td>
</tr>
<tr>
<td></td>
<td>(8)<strong>SELECT * FROM customers;</strong> 返回的结果集中包含T1在步骤3和步骤4中插入和修改的行</td>
</tr>
</tbody></table>
<h1 id="事务锁"><a href="#事务锁" class="headerlink" title="事务锁"></a>事务锁</h1><p>要实现并发事务，Oracle 数据库软件必须确保表中的数据一直有效。这可以通过<strong>锁(lock)</strong>来实现。下面这个例子：事务T1和T2都试图修改customers表中的顾客#1：</p>
<ol>
<li>T1执行一条UPDATE语句，修改顾客#1,但是T1并没有执行COMMIT语句。此时就称T1对该行“加锁”了。</li>
<li>T2也试图执行一条UPDATE语句，修改顾客#1，但是由于该行早已被T1加锁了，因此T2现在就不能获得该行的锁。T2的UPDATE语句必须一直等待，直到T1结束并释放该行上的锁为止。</li>
<li>T1执行COMMIT语句并结束，从而释放该行上的锁。</li>
<li>T2获得该行上的锁，并执行UPDATE语句。T2在获得该行上的锁后一直持有，直到T2结束为止。</li>
</ol>
<p>以上过程概括为： 当一个事务已经拥有某一行上的锁时，另外一个事务不能获得该行上的锁。</p>
<blockquote>
<p><strong>注意：</strong><br>理解默认加锁机制的最简单方法如下：<code>读程序(reader)</code>不会阻碍<code>读程序</code>；<code>写程序(writer)</code>不会阻碍<code>读程序</code>；只有在试图对相同的行进行修改时，<code>写程序</code>才会阻碍<code>写程序</code>。</p>
</blockquote>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p>在SQL的标准中，定义了四种隔离级别。每一种级别都规定了，在一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。低级别的隔离可以执行更高级别的并发，性能好，但是会出现脏读和幻读的现象。首先，我们从三个基础的概念说起：</p>
<ul>
<li><p><strong>脏读（dirty read）：</strong>两个事务，一个事务读取到了另一个事务未提交的数据，这便是脏读。</p>
</li>
<li><p><strong>幻读（phantom read）：</strong>两个事务，事务A与事务B，事务A在自己执行的过程中，执行了两次相同查询，第一次查询事务B未提交，第二次查询事务B已提交，从而造成两次查询结果不一样，这个其实被称为不可重复读；如果事务B是一个会影响查询结果的insert操作，则好像新多出来的行像幻觉一样，因此被称为幻读。其他事务的提交会影响在同一个事务中的重复查询结果。</p>
</li>
<li><p><strong>不可重复读（nonrepeatable read）：</strong>两个事务，事务T1读取一行，紧接着事务T2修改了T1刚才读取的那一行的内容。然后T1又读取了这一行，发现它与刚才读取的结果不同了。这种现象称为“不可重复读”，因为T1原来读取的那一行已经发生了变化。</p>
</li>
</ul>
<p>下面简单描述一下SQL中定义的四种标准隔离级别：</p>
<ol>
<li><strong>READ UNCOMMITTED (未提交读) ：</strong></li>
</ol>
<ul>
<li>隔离级别：0. </li>
<li>事物A和事物B，事物A未提交的数据，事物B可以读取到</li>
<li>可以读取未提交的记录。</li>
<li>会出现脏读。</li>
<li>这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别</li>
</ul>
<ol>
<li><strong>READ COMMITTED (提交读) ：</strong></li>
</ol>
<ul>
<li>隔离级别：1. </li>
<li>事物A和事物B，事物A提交的数据，事物B才能读取到</li>
<li>事务中只能看到已提交的修改。</li>
<li>不可重复读，会出现幻读。（在InnoDB中，会加行所，但是不会加间隙锁）</li>
<li>该隔离级别是大多数数据库系统(如Oracle)的默认隔离级别，但是MySQL的则是RR。</li>
</ul>
<ol>
<li><strong>REPEATABLE READ (可重复读) ：</strong></li>
</ol>
<ul>
<li>隔离级别：2. </li>
<li>事务A和事务B，事务A提交之后的数据，事务B读取不到</li>
<li>事务B是可重复读取数据</li>
<li>换句话说，对方提交之后的数据，我还是读取不到</li>
<li>MySQL默认级别</li>
<li>在InnoDB中是这样的：RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，因此不存在幻读现象。但是标准的RR只能保证在同一事务中多次读取同样记录的结果是一致的，而无法解决幻读问题。</li>
<li>InnoDB的幻读解决是依靠MVCC的实现机制做到的。</li>
</ul>
<ol>
<li><strong>SERIALIZABLE （可串行化）：</strong></li>
</ol>
<ul>
<li>隔离级别：3. </li>
<li>事务A和事务B，事务A在操作数据库时，事务B只能排队等待</li>
<li>这种隔离级别很少使用，吞吐量太低，用户体验差</li>
<li>这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发</li>
<li>该隔离级别会在读取的每一行数据上都加上锁，退化为基于锁的并发控制，即LBCC。
　　<blockquote>
<p>需要注意的是，MVCC只在RC和RR两个隔离级别下工作，其他两个隔离级别都和MVCC不兼容。</p>
</blockquote>
</li>
</ul>
<h2 id="设置事务隔离级别"><a href="#设置事务隔离级别" class="headerlink" title="设置事务隔离级别"></a>设置事务隔离级别</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><ul>
<li><p>可以在my.ini文件中使用transaction-isolation选项来设置服务器的缺省事务隔离级别。</p>
</li>
<li><p>该选项值可以是</p>
<pre><code>– READ-UNCOMMITTED
– READ-COMMITTED
– REPEATABLE-READ
– SERIALIZABLE

•   例如：
[mysqld]
transaction-isolation = READ-COMMITTED</code></pre></li>
</ul>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><ul>
<li>通过命令动态设置隔离级别<ul>
<li>隔离级别也可以在运行的服务器中动态设置，应使用SET TRANSACTION ISOLATION LEVEL语句。</li>
<li>其语法模式为：<pre><code>SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL &lt;isolation-level&gt;
其中的&lt;isolation-level&gt;可以是：
–   READ UNCOMMITTED
–   READ COMMITTED
–   REPEATABLE READ
–   SERIALIZABLE
•   例如： SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;</code></pre></li>
</ul>
</li>
</ul>
<h2 id="隔离级别的作用范围"><a href="#隔离级别的作用范围" class="headerlink" title="隔离级别的作用范围"></a>隔离级别的作用范围</h2><pre><code>•   事务隔离级别的作用范围分为两种： 
–   全局级：对所有的会话有效 
–   会话级：只对当前的会话有效 
•   例如，设置会话级隔离级别为READ COMMITTED ：
mysql&gt; SET TRANSACTION ISOLATION LEVEL READ COMMITTED；
或：
mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED；
•   设置全局级隔离级别为READ COMMITTED ： 
mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED；</code></pre><h2 id="查看隔离级别"><a href="#查看隔离级别" class="headerlink" title="查看隔离级别"></a>查看隔离级别</h2><pre><code>select @@global.tx_isolation, @@tx_isolation 和 show variables like &apos;%isolation%&apos;</code></pre><blockquote>
<p>关于事务隔离级别，锁，以及并发控制与加锁分析，可参考的技术博客<br>    <a href="https://xtzhu.github.io/2019/03/20/%E9%9D%A2%E8%AF%95%E9%A2%9870-80/#20">事务隔离级别</a><br>    <a href="https://www.cnblogs.com/yelbosh/p/5813865.html" target="_blank" rel="noopener">并发控制与加锁分析</a><br>    <a href="https://note.youdao.com/ynoteshare1/index.html?id=daad612052801c77458ee3fa5b366e20&type=note&from=timeline&isappinstalled=0#/" target="_blank" rel="noopener">MySQL 加锁处理分析</a></p>
</blockquote>
<blockquote>
<p>引用的技术博客<br>    <a href="https://blog.csdn.net/w_linux/article/details/79666086" target="_blank" rel="noopener">MySQL——事务(Transaction)详解</a></p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xtzhu.github.io/2019/04/08/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XTZhu">
      <meta itemprop="description" content="learnLess">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PPPig's TreeHole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/04/08/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/" class="post-title-link" itemprop="url">TCP三次握手与四次挥手</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-08 22:06:20" itemprop="dateCreated datePublished" datetime="2019-04-08T22:06:20+08:00">2019-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-05-09 15:37:47" itemprop="dateModified" datetime="2019-05-09T15:37:47+08:00">2019-05-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>参考资料：<a href="https://blog.csdn.net/sinat_36629696/article/details/80740678" target="_blank" rel="noopener">https://blog.csdn.net/sinat_36629696/article/details/80740678</a><br><a href="https://blog.csdn.net/qq_38950316/article/details/81087809" target="_blank" rel="noopener">https://blog.csdn.net/qq_38950316/article/details/81087809</a></p>
</blockquote>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>TCP协议全称: 传输控制协议, 顾名思义, 就是要对数据的传输进行一定的控制.<br><img src="https://raw.githubusercontent.com/XTZhu/image/master/blog/20180717201939345.jpg" alt="TCP报头"><br>我们来分析分析每部分的含义和作用</p>
<ul>
<li><p>源端口号/目的端口号: 表示数据从哪个进程来, 到哪个进程去.</p>
</li>
<li><p>32位序号:</p>
<blockquote>
<p> 序列号<code>seq</code>：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号</p>
</blockquote>
</li>
<li><p>32位确认号： </p>
<blockquote>
<p>确认号<code>ack</code>：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。</p>
</blockquote>
</li>
<li><p>4位首部长度: 表示该tcp报头有多少个4字节(32个bit)</p>
</li>
<li><p>6位保留: 顾名思义, 先保留着, 以防万一</p>
</li>
<li><p>6位标志位</p>
<blockquote>
<ul>
<li>URG: 标识紧急指针是否有效 </li>
<li>ACK: 标识确认序号是否有效 </li>
<li>PSH: 用来提示接收端应用程序立刻将数据从tcp缓冲区读走 </li>
<li>RST: 要求重新建立连接. 我们把含有RST标识的报文称为复位报文段 </li>
<li>SYN: 请求建立连接. 我们把含有SYN标识的报文称为同步报文段 </li>
<li>FIN: 通知对端, 本端即将关闭. 我们把含有FIN标识的报文称为结束报文段</li>
</ul>
</blockquote>
</li>
<li><p>16位窗口大小:</p>
</li>
<li><p>16位检验和: 由发送端填充, 检验形式有CRC校验等. 如果接收端校验不通过, 则认为数据有问题. 此处的校验和不光包含TCP首部, 也包含TCP数据部分.</p>
</li>
<li><p>16位紧急指针: 用来标识哪部分数据是紧急数据.<br>选项和数据暂时忽略</p>
</li>
</ul>
<blockquote>
<p> PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号</p>
</blockquote>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>URG</td>
<td>紧急指针是否有效。为1，表示某一位需要被优先处理</td>
</tr>
<tr>
<td>ACK</td>
<td>确认号是否有效，一般置为1。</td>
</tr>
<tr>
<td>PSH</td>
<td>提示接收端应用程序立即从TCP缓冲区把数据读走。</td>
</tr>
<tr>
<td>RST</td>
<td>对方要求重新建立连接，复位。</td>
</tr>
<tr>
<td>SYN</td>
<td>请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1</td>
</tr>
<tr>
<td>FIN</td>
<td>希望断开连接。</td>
</tr>
</tbody></table>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><strong>TCP的连接建立是一个三次握手过程，目的是为了通信双方确认开始序号，以便后续</strong><br><img src="https://raw.githubusercontent.com/XTZhu/image/master/blog/20180717202520531.png" alt="三次握手"><br>主要步骤如下：<br>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><strong>TCP终止连接的四次挥手过程如下：</strong><br><img src="https://raw.githubusercontent.com/XTZhu/image/master/blog/20180717204202563.png" alt="四次挥手"></p>
<ol>
<li><p>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，<code>FIN=1</code>，其序列号为<code>seq=u</code>（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入 <code>FIN-WAIT-1</code>（终止等待1）状态。 TCP规定，<code>FIN</code>报文段即使不携带数据，也要消耗一个序号。  </p>
</li>
<li><p>服务器收到连接释放报文，发出确认报文，<code>ACK=1，ack=u+1</code>，并且带上自己的序列号<code>seq=v</code>，此时，服务端就进入了 <code>CLOSE-WAIT</code>（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 <code>CLOSE-WAIT</code> 状态持续的时间。  </p>
</li>
<li><p>客户端收到服务器的确认请求后，此时，客户端就进入 <code>FIN-WAIT-2</code>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 </p>
</li>
<li><p>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<code>FIN=1，ack=u+1</code>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为<code>seq=w</code>，此时，服务器就进入了 <code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。  </p>
</li>
<li><p>客户端收到服务器的连接释放报文后，必须发出确认，<code>ACK=1，ack=w+1</code>，而自己的序列号是<code>seq=u+1</code>，此时，客户端就进入了<code>TIME-WAIT</code>（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗<code>MSL</code>（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入<code>CLOSED</code>状态。 </p>
</li>
<li><p>服务器只要收到了客户端发出的确认，立即进入<code>CLOSED</code>状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，<em>服务器结束TCP连接的时间要比客户端早一些</em>。</p>
</li>
</ol>
<blockquote>
<p>补充引用链接：<a href="https://www.cnblogs.com/zmlctt/p/3690998.html" target="_blank" rel="noopener">https://www.cnblogs.com/zmlctt/p/3690998.html</a><br><a href="https://mp.weixin.qq.com/s/L-eSLMFQGVmVJzmqHgFHtw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/L-eSLMFQGVmVJzmqHgFHtw</a></p>
</blockquote>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><ol>
<li><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
<blockquote>
<p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
</blockquote>
</li>
<li><p>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<blockquote>
<p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。<br>所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。<br>所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
</blockquote>
</li>
<li><p>为什么不能用两次握手进行连接？</p>
<blockquote>
<p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
</blockquote>
</li>
<li><p>如果已经建立了连接，但是客户端突然出现故障了怎么办？</p>
<blockquote>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔<strong>75秒钟</strong>发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
</blockquote>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xtzhu.github.io/2019/03/20/%E9%9D%A2%E8%AF%95%E9%A2%9870-80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XTZhu">
      <meta itemprop="description" content="learnLess">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PPPig's TreeHole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/03/20/%E9%9D%A2%E8%AF%95%E9%A2%9870-80/" class="post-title-link" itemprop="url">面试题61-80</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-03-20 22:06:20" itemprop="dateCreated datePublished" datetime="2019-03-20T22:06:20+08:00">2019-03-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2019-04-09 11:09:28" itemprop="dateModified" datetime="2019-04-09T11:09:28+08:00">2019-04-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li><strong>编写多线程程序有几种实现方式？</strong></li>
<li><strong>synchronized关键字的用法?</strong></li>
<li><strong>举例说明同步和异步</strong></li>
<li><strong>启动一个线程是调用run()还是start()方法？</strong></li>
<li><strong>什么是线程池（thread pool）?</strong></li>
<li><strong>线程的基本状态以及状态之间的关系？</strong></li>
<li><strong>简述synchronized 和java.util.concurrent.locks.Lock的异同</strong></li>
<li><strong>Java中如何实现序列化，有什么意义？</strong></li>
<li><strong>Java中有几种类型的流？</strong></li>
<li><strong>写一个方法，输入一个文件名和一个字符串，统计这个字符串在这个文件中出现的次数。</strong></li>
<li><strong>如何用Java代码列出一个目录下所有的文件？</strong></li>
<li><strong>用Java的套接字编程实现一个多线程的回显（echo）服务器？</strong></li>
<li><strong>XML文档定义有几种形式？它们之间有何本质区别？解析XML文档有哪几种方式？</strong></li>
<li><strong>你在项目中哪些地方用到了XML？</strong></li>
<li><strong>阐述JDBC操作数据库的步骤。</strong></li>
<li><strong>Statement和PreparedStatement有什么区别？哪个性能更好？</strong></li>
<li><strong>使用JDBC操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</strong></li>
<li><strong>在进行数据库编程时，连接池有什么作用？</strong></li>
<li><strong>什么是DAO模式？</strong></li>
<li><strong>事务的ACID是指什么</strong></li>
</ol>
<blockquote>
<p>博客原文：<a href="https://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="noopener">https://blog.csdn.net/jackfrued/article/details/44921941</a> </p>
</blockquote>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ul>
<li>Java 5 以前实现多线程有两种方式。1.继承<code>Thread</code>类；2.实现<code>Runnable</code>接口。</li>
<li>两种方法都要通过重写<code>run()</code>方法来定义线程的行为，推荐使用后者，因为Java中的继承是单继承，一个类有一个父类，如果继承了Thread类之后就无法继承其它类了。</li>
<li>Java5 以后还可以实现<code>Callable</code>接口，其中的<code>call()</code>可以在线程执行结束时产生一个返回值。</li>
</ul>
<blockquote>
<p>(MyTask.java)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> upperBounds;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(<span class="keyword">int</span> upperBounds)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.upperBounds = upperBounds;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= upperBounds; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            sum += i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        List&lt;Future&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            list.add(service.submit(<span class="keyword">new</span> MyTask((<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>))));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(Future&lt;Integer&gt; future : list) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// while(!future.isDone()) ;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">            sum += future.get();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">        System.out.println(sum);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>synchronized 关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，可以用<code>synchronized(对象){...}</code>定义同步代码块，或者在声明方法时将synchronized作为方法的修饰符。（60题需要回顾）</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>如果系统中存在临界资源(资源数量少于竞争资源的线程数量的资源),例如正在写的数据以后可能被另一个线程读到,或者正在读的数据可能已经被另一个线程写过了,那么这些数据就必须进行同步存取(数据库操作中的排他锁就是最好的例子).当应用程序在对象上调用了一个需要花费很长时间来执行的方法,并且不希望让程序等待方法的返回时,就应该使用异步编程,在很多情况下采用异步途径往往更有效率.事实上,所谓的同步就是指阻塞式操作,而异步就是非阻塞式操作.</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>启动一个线程是调用<code>start()</code>方法,使线程所代表的虚拟处理机处于可运行状态,这意味着它可以由JVM调度并执行,这并不意味着线程就会立即运行,<code>run()</code>方法是线程启动后要进行callback的方法.</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>在面向对象编程中，创建和销毁对象是很费时间的，因为创建一个对象要获取内存资源或者其它更多资源。在Java中更是如此，虚拟机将试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以提高服务程序效率的一个手段就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是”池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程不用自行创建，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。<br>Java 5+中的Executor接口定义一个执行线程的工具。它的子类型即线程池接口是ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，因此在工具类Executors面提供了一些静态工厂方法，生成一些常用的线程池，如下所示： </p>
<ul>
<li>newSingleThreadExecutor：创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。 </li>
<li><code>newFixedThreadPool</code>：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。 </li>
<li>newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。 </li>
<li>newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。 </li>
<li>newSingleThreadExecutor：创建一个单线程的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<p>第60题的例子中演示了通过Executors工具类创建线程池并使用线程池执行线程的代码。如果希望在服务器上使用线程池，强烈建议使用<code>newFixedThreadPool</code>方法来创建线程池，这样能获得更好的性能。</p>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p><img src="https://raw.githubusercontent.com/XTZhu/image/master/blog/20190320-01.png" alt="photo"></p>
<blockquote>
<p>其中Running表示运行状态，Runnable表示就绪状态（万事俱备，只欠CPU），Blocked表示阻塞状态，阻塞状态又有多种情况，可能是因为调用wait()方法进入等待池，也可能是执行同步方法或同步代码块进入等锁池，或者是调用了sleep()方法或join()方法等待休眠或其他线程结束，或是因为发生了I/O中断。</p>
</blockquote>
<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p><code>Lock</code> 是 Java 5 之后引入的新的API，和关键字<code>synchronized</code> 相比主要共同点： <code>Lock</code>能完成<code>synchronized</code>所实现的所有功能；主要不同点： <code>Lock</code>有比<code>synchronized</code>更精确的线程语义和更好的性能，而且不强制性要求一定要获得锁。<code>synchronized</code>会自动释放锁，而<code>Lock</code>一定要求程序员手动释放，而且最好在finally块中释放（这是释放外部资源的最好的地方）。</p>
<h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）</p>
<p>要实现序列化，需要让类实现一个<code>Serializable</code>接口，该接口是一个标识性接口，标注该类对象是可以被序列化的，然后使用一个输出流来构造一个对象输出流并通过<code>writeObject(Object)</code>方法就可以将实现对象写出（保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过<code>readObject</code>方法从流中读取对象。序列化除了能够实现对象的持久化以外，还能用于对象的深度克隆。</p>
<blockquote>
<p>面试题 实现文件拷贝。 MyUtil.java</p>
</blockquote>
<h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>字节流和字符流。字节流继承于<code>InputStream</code>、<code>OutputStream</code>, 字符流继承于<code>Reader</code>、<code>Writer</code>。在java.io包中还有许多其它的流。主要是为了提高性能和使用方便。关于java的I/O需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外java中的流不同于C#的是它只有一个维度一个方向。</p>
<h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><blockquote>
<p>countWordInFile.java</p>
</blockquote>
<h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><p>如果只要求列出当前文件夹下的文件，代码如下所示：</p>
<pre><code>import java.io.File;

class Test12 {

    public static void main(String[] args) {
        File f = new File(&quot;/Users/Hao/Downloads&quot;);
        for(File temp : f.listFiles()) {
            if(temp.isFile()) {
                System.out.println(temp.getName());
            }
        }
    }
}</code></pre><p>如果需要对文件夹继续展开，代码如下所示：</p>
<pre><code>import java.io.File;

class Test12 {

public static void main(String[] args) {
    showDirectory(new File(&quot;/Users/Hao/Downloads&quot;));
}

public static void showDirectory(File f) {
    _walkDirectory(f, 0);
}

private static void _walkDirectory(File f, int level) {
    if(f.isDirectory()) {
        for(File temp : f.listFiles()) {
            _walkDirectory(temp, level + 1);
        }
    }
    else {
        for(int i = 0; i &lt; level - 1; i++) {
            System.out.print(&quot;\t&quot;);
        }
        System.out.println(f.getName());
    }
}</code></pre><p>}</p>
<p>在Java 7中可以使用NIO.2的API来做同样的事情，代码如下所示：</p>
<pre><code>class ShowFileTest {

    public static void main(String[] args) throws IOException {
        Path initPath = Paths.get(&quot;/Users/Hao/Downloads&quot;);
        Files.walkFileTree(initPath, new SimpleFileVisitor&lt;Path&gt;() {

            @Override
            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) 
                    throws IOException {
                System.out.println(file.getFileName().toString());
                return FileVisitResult.CONTINUE;
            }

        });
    }
}</code></pre><h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><blockquote>
<p>EchoServer.java</p>
</blockquote>
<h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><p>XML文档定义为DTD和Schema两种形式，二者都是对XML语法的约束，其本质区别在于Schema本身也是一个XML文件，可以被XML解析器解析，而且可以为XML承载的数据定义类型，约束能力较之DTD更强大。对XML的解析主要有DOM和StAX，其中DOM处理大型文件时其性能下降的非常厉害，这个问题是由DOM树结构占用的内存较多造成的，而且DOM解析方式必须在解析文件之前把整个文档装入内存，适合对XML的随机访问（空间换时间）；SAX是事件驱动型的XML解析方式，它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过事件回调代码来处理XML文件，适合对XML的顺序访问；顾名思义，StAX把重点放在流上，实际上StAX与其他解析方式的本质区别就在于应用程序能够把XML作为一个事件流来处理。将XML作为一组事件来处理的想法并不新颖（SAX就是这样做的），但不同之处在于StAX允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</p>
<h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><p>XML的主要作用有两个方面：数据交换和信息配置。在做数据交换时，XML将数据用标签组装起来，然后压缩打包加密后通过网络传输给接收者，接收解密与解压缩后再从XML文件中花园相关信息处理，XML曾经是异构系统间交换数据的事实标准，但现在几乎已经被JSON代替。<br>然多软件现在依然使用XML存储配置信息，很多项目中都将作为配置信息的硬代码写在XML文件中，Java的很多框架也是这么做的，但是用了dom4j代替Sun公司的API</p>
<blockquote>
<p>现在有很多时髦的软件（如Sublime）已经开始将配置文件书写成JSON格式，我们已经强烈的感受到XML的另一项功能也将逐渐被业界抛弃。</p>
</blockquote>
<h3 id="15"><a href="#15" class="headerlink" title="15"></a>15</h3><ul>
<li><p>加载驱动。</p>
<blockquote>
<p> Class.forName(“oracle.jdbc.driver.OracleDriver”);</p>
</blockquote>
</li>
<li><p>创建连接</p>
<blockquote>
<p>Connection con = DriverManager.getConnection(“jdbc:oracle:thin:@localhost:1521:orcl”, “scott”, “tiger”);</p>
</blockquote>
</li>
<li><p>创建语句。</p>
<blockquote>
<p>PreparedStatement ps = con.prepareStatement(“select * from emp where sal between ? and ?”);<br>  ps.setInt(1, 1000);<br>  ps.setInt(2, 3000);</p>
</blockquote>
</li>
<li><p>执行语句。</p>
<blockquote>
<p>ResultSet rs = ps.executeQuery();</p>
</blockquote>
</li>
<li><p>处理结果</p>
<blockquote>
<p>   while(rs.next()) {</p>
<pre><code>System.out.println(rs.getInt(&quot;empno&quot;) + &quot; - &quot; + rs.getString(&quot;ename&quot;));</code></pre><p>  }</p>
</blockquote>
</li>
<li><p>关闭资源。</p>
<blockquote>
<p> finally {</p>
<pre><code>if(con != null) {
    try {
        con.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}</code></pre><p>  }<br>关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭ResultSet、再关闭Statement、在关闭Connection。上面的代码只关闭了Connection（连接），虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在JDBC 4.0中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。</p>
</blockquote>
</li>
</ul>
<h3 id="16"><a href="#16" class="headerlink" title="16"></a>16</h3><p>与Statement相比，</p>
<ul>
<li>①PreparedStatement接口代表预编译的语句，它主要的优势在于可以减少SQL的编译错误并增加SQL的安全性（减少SQL注射攻击的可能性）；</li>
<li>②PreparedStatement中的SQL语句是可以带参数的，避免了用字符串连接拼接SQL语句的麻烦和不安全；</li>
<li>③当批量处理SQL或频繁执行相同的查询时，PreparedStatement有明显的性能上的优势，由于数据库可以将编译优化后的SQL语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</li>
</ul>
<blockquote>
<p>为了提供对存储过程的调用，JDBC API中还提供了CallableStatement接口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的SQL语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦，因为每种数据库的存储过程在书写上存在不少的差别。</p>
</blockquote>
<h3 id="17"><a href="#17" class="headerlink" title="17"></a>17</h3><p>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）；要提升更新数据的性能可以使用PreparedStatement语句构建批处理，将若干SQL语句置于一个批处理中执行。</p>
<h3 id="18"><a href="#18" class="headerlink" title="18"></a>18</h3><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：<code>C3P0</code>、<code>Proxool</code>、<code>DBCP</code>、<code>BoneCP</code>、<code>Druid</code>等。</p>
<blockquote>
<p>在计算机系统中<code>时间</code>和<code>空间</code>是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。</p>
</blockquote>
<h3 id="19"><a href="#19" class="headerlink" title="19"></a>19</h3><p>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。DAO模式实际上包含了两个模式，一是Data Accessor（数据访问器），二是Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p>
<h3 id="20"><a href="#20" class="headerlink" title="20"></a>20</h3><ul>
<li>原子性(Atomic)：事务中各项操作，要么全做要么全不做，任何一项操作的失败都会导致整个事务的失败； </li>
<li>一致性(Consistent)：事务结束后系统状态是一致的； </li>
<li>隔离性(Isolated)：并发执行的事务彼此无法看到对方的中间状态； </li>
<li>持久性(Durable)：事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志和同步备份可以在故障发生后重建数据。</li>
</ul>
<blockquote>
<p>关于事务，在面试中被问到的概率是很高的，可以问的问题也是很多的。首先需要知道的是，只有存在并发数据访问时才需要事务。当多个事务访问同一数据时，可能会存在5类问题，包括3类数据读取问题（脏读、不可重复读和幻读）和2类数据更新问题（第1类丢失更新和第2类丢失更新）。</p>
</blockquote>
<p>脏读（Dirty Read）：A事务读取B事务尚未提交的数据并在此基础上操作，而B事务执行回滚，那么A读取到的数据就是脏数据。</p>
<p>|时间|转账事务A|取款事务B|<br>|-|-|<br>|T1||开始事务|<br>|T2|开始事务||<br>|T3||查询账户余额为1000元|<br>|T4||取出500元余额修改为500元|<br>|T5|查询账户余额为500元（脏读）||<br>|T6||撤销事务余额恢复为1000元|<br>|T7|汇入100元把余额修改为600元||<br>|T8|提交事务||</p>
<p>不可重复读（Unrepeatable Read）：事务A重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务B修改过了。</p>
<p>|时间|转账事务A|取款事务B|<br>|-|-|<br>|T1||开始事务|<br>|T2|开始事务||<br>|T3||查询账户余额为1000元|<br>|T4|查询账户余额为1000元||<br>|T5||取出100元修改余额为900元|<br>|T6||提交事务|<br>|T7|查询账户余额为900元（不可重复读）||</p>
<p>幻读（Phantom Read）：事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中插入了被事务B提交的行。</p>
<p>|时间|统计金额事务A|取款事务B|<br>|-|-|<br>|T1||开始事务|<br>|T2|开始事务||<br>|T3|统计总存款为10000元||<br>|T4||新增一个存款账户存入100元|<br>|T5||提交事务|<br>|T6|再次统计总存款为10100元（幻读）||</p>
<p>第1类丢失更新：事务A撤销时，把已经提交的事务B的更新数据覆盖了。</p>
<p>|时间|取款事务A|转账事务B|<br>|-|-|<br>|T1|开始事务||<br>|T2||开始事务|<br>|T3|查询账户余额为1000元||<br>|T4||查询账户余额为1000元|<br>|T5||汇入100元修改余额为1100元|<br>|T6||提交事务|<br>|T6|取出100元将余额修改为900元||<br>|T6|撤销事务||<br>|T6|余额恢复为1000元（丢失更新）||</p>
<p>第2类丢失更新：事务A覆盖事务B已经提交的数据，造成事务B所做的操作丢失。</p>
<p>|时间|转账事务A|取款事务B|<br>|-|-|<br>|T1||开始事务|<br>|T2|开始事务||<br>|T3||查询账户余额为1000元|<br>|T4|查询账户余额为1000元||<br>|T5||取出100元将余额修改为900元|<br>|T6||提交事务|<br>|T6|汇入100元将余额修改为1100元||<br>|T6|提交事务||<br>|T6|查询账户余额为1100元（丢失更新）||</p>
<p>数据并发访问所产生的问题，在有些场景下可能是允许的，但是有些场景下可能就是致命的，数据库通常会通过锁机制来解决数据并发访问问题，按锁定对象不同可以分为表级锁和行级锁；按并发事务锁定关系可以分为共享锁和独占锁，具体的内容大家可以自行查阅资料进行了解。<br>直接使用锁是非常麻烦的，为此数据库为用户提供了自动锁机制，只要用户指定会话的事务隔离级别，数据库就会通过分析SQL语句然后为事务访问的资源加上合适的锁，此外，数据库还会维护这些锁通过各种手段提高系统的性能，这些对用户来说都是透明的（就是说你不用理解，事实上我确实也不知道）。ANSI/ISO SQL 92标准定义了4个等级的事务隔离级别，如下表所示：</p>
<p>|隔离级别|脏读    |不可重复读    |幻读|第一类丢失更新|第二类丢失更新|<br>|-|-|-|-|<br>|READ UNCOMMITED|允许|允许|允许|不允许|允许|<br>|READ COMMITTED|不允许|允许|允许|不允许|允许|<br>|REPEATABLE READ|不允许|不允许|允许|不允许|不允许|<br>|SERIALIZABLE|不允许|不允许|不允许|不允许|不允许|</p>
<p>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xtzhu.github.io/2019/02/25/0225-%E9%9D%A2%E8%AF%95%E9%A2%9850-60/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XTZhu">
      <meta itemprop="description" content="learnLess">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PPPig's TreeHole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/25/0225-%E9%9D%A2%E8%AF%95%E9%A2%9850-60/" class="post-title-link" itemprop="url">0225_面试题50-60</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-02-25 20:32:12 / Modified: 21:17:21" itemprop="dateCreated datePublished" datetime="2019-02-25T20:32:12+08:00">2019-02-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol>
<li><strong>类ExampleA继承Exception，类ExampleB继承ExampleA 有如下代码片断： 请问执行此段代码的输出是什么？</strong></li>
<li><strong>List、Set、Map是否继承自Collection接口？</strong></li>
<li><strong>阐述ArrayList、Vector、LinkedList的存储性能和特性</strong></li>
<li><strong>Collection和Collections的区别？</strong></li>
<li><strong>List、Map、Set三个接口存取元素时，各有什么特点？</strong></li>
<li><strong>TreeMap和TreeSet在排序时如何比较元素？Collections工具类中的sort()方法如何比较元素？</strong></li>
<li><strong>Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</strong></li>
<li><strong>线程的sleep()方法和yield()方法有什么区别？</strong></li>
<li><strong>当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</strong></li>
<li><strong>请说出与线程同步以及线程调度相关的方法。</strong></li>
</ol>
<blockquote>
<p>博客原文：<a href="https://blog.csdn.net/jackfrued/article/details/44921941" target="_blank" rel="noopener">https://blog.csdn.net/jackfrued/article/details/44921941</a> </p>
</blockquote>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExampleB(<span class="string">"b"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span>（ExampleA e）&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"ExampleA"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span>（Exception e）&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    System.out.println(<span class="string">"Exception"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>输出：ExampleA。（根据里氏代换原则[能使用父类型的地方一定能使用子类型]，抓取ExampleA类型异常的catch块能够抓住try块中抛出的ExampleB类型的异常）</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>List、Set 是，Map 不是。Map是键值对映射容器，与List和Set有明显的区别，而Set存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。</p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>ArrayList 和Vector都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collections中的synchronizedList方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>Collection是一个接口，它是Set、List等容器的父接口；Collections是个一个工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>List以特定索引来存取元素，可以有重复元素。Set不能存放重复元素（用对象的equals()方法来区分元素是否重复）。Map保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。</p>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>TreeSet要求存放的对象所属的类必须实现Comparable接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap要求存放的键值对映射的键必须实现Comparable接口从而根据键对元素进行排序。Collections工具类的sort方法有两种重载的形式，第一种要求传入的待排序容器中存放的对象比较实现Comparable接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator接口的子类型（需要重写compare方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。 </p>
<p>例子1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;        <span class="comment">// 姓名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;            <span class="comment">// 年龄</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.age = age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age; <span class="comment">// 比较年龄(年龄的升序)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Set;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test01</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        Set&lt;Student&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();     <span class="comment">// Java 7的钻石语法(构造器后面的尖括号中不需要写类型)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"Hao LUO"</span>, <span class="number">33</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"XJ WANG"</span>, <span class="number">32</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"Bruce LEE"</span>, <span class="number">60</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        set.add(<span class="keyword">new</span> Student(<span class="string">"Bob YANG"</span>, <span class="number">22</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(Student stu : set) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            System.out.println(stu);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      输出结果: </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      Student [name=Bob YANG, age=22]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      Student [name=XJ WANG, age=32]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      Student [name=Hao LUO, age=33]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      Student [name=Bruce LEE, age=60]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">// 姓名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;        <span class="comment">// 年龄</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.name = name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.age = age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 获取学生姓名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> name;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 获取学生年龄</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"Student [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collections;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Comparator;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test02</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();     <span class="comment">// Java 7的钻石语法(构造器后面的尖括号中不需要写类型)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Hao LUO"</span>, <span class="number">33</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"XJ WANG"</span>, <span class="number">32</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Bruce LEE"</span>, <span class="number">60</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">"Bob YANG"</span>, <span class="number">22</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 通过sort方法的第二个参数传入一个Comparator接口对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 相当于是传入一个比较对象大小的算法到sort方法中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 由于Java中没有函数指针、仿函数、委托这样的概念</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 因此要将一个算法传入一个方法中唯一的选择就是通过接口回调</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Student&gt; () &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="meta">@Override</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Student o1, Student o2)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">return</span> o1.getName().compareTo(o2.getName());    <span class="comment">// 比较学生姓名</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(Student stu : list) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            System.out.println(stu);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      输出结果: </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      Student [name=Bob YANG, age=22]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      Student [name=Bruce LEE, age=60]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      Student [name=Hao LUO, age=33]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//      Student [name=XJ WANG, age=32]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复（线程回到就绪状态，请参考第66题中的线程状态转换图）。wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p>
<blockquote>
<p>可能不少人对什么是进程，什么是线程还比较模糊，对于为什么需要多线程编程也不是特别理解。简单的说：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，是操作系统进行资源分配和调度的一个独立单位；线程是进程的一个实体，是CPU调度和分派的基本单位，是比进程更小的能独立运行的基本单位。线程的划分尺度小于进程，这使得多线程程序的并发性高；进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。使用多线程的编程通常能够带来更好的性能和用户体验，但是多线程的程序对于其他程序是不友好的，因为它可能占用了更多的CPU资源。当然，也不是线程越多，程序的性能就越好，因为线程之间的调度和切换也会浪费CPU时间。时下很时髦的Node.js就采用了单线程异步I/O的工作模式。</p>
</blockquote>
<h3 id="8"><a href="#8" class="headerlink" title="8"></a>8</h3><ul>
<li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； </li>
<li>线程执行sleep()方法后转入阻塞（blocked）状态，而执行yield()方法后转入就绪（ready）状态； </li>
<li>sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常； </li>
<li>sleep()方法比yield()方法（跟操作系统CPU调度相关）具有更好的可移植性。</li>
</ul>
<h3 id="9"><a href="#9" class="headerlink" title="9"></a>9</h3><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池哦）中等待对象的锁。</p>
<h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><ul>
<li>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； </li>
<li>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理InterruptedException异常； </li>
<li>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； </li>
<li>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</li>
</ul>
<blockquote>
<p>Java 5通过Lock接口提供了显式的锁机制（explicit lock），增强了灵活性以及对线程的协调。Lock接口中定义了加锁（lock()）和解锁（unlock()）的方法，同时还提供了newCondition()方法来产生用于线程之间通信的Condition对象；此外，Java 5还提供了信号量机制（semaphore），信号量可以用来限制对某个共享资源进行访问的线程的数量。在对资源进行访问之前，线程必须得到信号量的许可（调用Semaphore对象的acquire()方法）；在完成对资源的访问后，线程必须向信号量归还许可（调用Semaphore对象的release()方法）。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xtzhu.github.io/2019/02/25/%E4%B8%AD%E7%BA%A7%E8%84%9A%E6%9C%AC%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XTZhu">
      <meta itemprop="description" content="learnLess">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PPPig's TreeHole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/25/%E4%B8%AD%E7%BA%A7%E8%84%9A%E6%9C%AC%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">中级脚本算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-02-25 20:05:58 / Modified: 20:04:23" itemprop="dateCreated datePublished" datetime="2019-02-25T20:05:58+08:00">2019-02-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="中级脚本算法"><a href="#中级脚本算法" class="headerlink" title="中级脚本算法"></a>中级脚本算法</h1><h2 id="1-区间求值算法挑战"><a href="#1-区间求值算法挑战" class="headerlink" title="1. 区间求值算法挑战"></a>1. 区间求值算法挑战</h2><p>我们会传递给你一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。</p>
<p>最小的数字并非总在最前面。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumAll</span>(<span class="params">arr</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> num1 = arr[<span class="number">0</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> num2 = arr[<span class="number">1</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(num1&gt;num2)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        snum = num1-num2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">      snum = num2-num1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> (num1+num2)*(snum+<span class="number">1</span>)/<span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">sumAll([<span class="number">1</span>, <span class="number">4</span>]);</span></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sumAll</span>(<span class="params">arr</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(arr[<span class="number">0</span>],arr[<span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(arr[<span class="number">0</span>],arr[<span class="number">1</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = [];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;=max-min;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">newArr[i] = min+i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> newArr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a+b;&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">sumAll([<span class="number">1</span>, <span class="number">4</span>]);</span></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://xtzhu.github.io/2019/02/25/%E5%88%9D%E7%BA%A7%E8%84%9A%E6%9C%AC%E7%AE%97%E6%B3%95-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="XTZhu">
      <meta itemprop="description" content="learnLess">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="PPPig's TreeHole">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/02/25/%E5%88%9D%E7%BA%A7%E8%84%9A%E6%9C%AC%E7%AE%97%E6%B3%95-3/" class="post-title-link" itemprop="url">初级脚本算法-3</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2019-02-25 18:05:58 / Modified: 19:42:01" itemprop="dateCreated datePublished" datetime="2019-02-25T18:05:58+08:00">2019-02-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="初级脚本算法-3"><a href="#初级脚本算法-3" class="headerlink" title="初级脚本算法-3"></a>初级脚本算法-3</h1><h2 id="10-数组分割算法挑战"><a href="#10-数组分割算法挑战" class="headerlink" title="10. 数组分割算法挑战"></a>10. 数组分割算法挑战</h2><p>编写一个函数,把一个数组<code>arr</code>按照指定的数组大小<code>size</code>分割成若干个数组块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">arr, size</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Break it up.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> newArr = [];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; arr.length;i = i + size)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    newArr.push(arr.slice(i,i+size));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> newArr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">chunk([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>], <span class="number">2</span>);</span></pre></td></tr></table></figure>
<h2 id="11-数组截断算法挑战"><a href="#11-数组截断算法挑战" class="headerlink" title="11. 数组截断算法挑战"></a>11. 数组截断算法挑战</h2><p> 返回一个数组被截断<code>n</code>个元素后还剩余的元素，从索引0开始截断。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">slasher</span>(<span class="params">arr, howMany</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// it doesn't always pay to be first</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span>(arr.length&lt;=howMany)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> [];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> arr.slice(howMany)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">slasher([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>);</span></pre></td></tr></table></figure>

<h2 id="12-数组查询算法挑战"><a href="#12-数组查询算法挑战" class="headerlink" title="12. 数组查询算法挑战"></a>12. 数组查询算法挑战</h2><p> 如果数组第一个字符串元素包含了第二个字符串元素的所有字符，则函数返回true。</p>
<p> 举例，<code>[&quot;hello&quot;, &quot;Hello&quot;]</code>应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。</p>
<p> <code>[&quot;hello&quot;, &quot;hey&quot;]</code>应该返回false，因为字符串”hello”并不包含字符”y”。</p>
<p> <code>[&quot;Alien&quot;, &quot;line&quot;]</code>应该返回true，因为”line”中所有字符都可以在”Alien”找到。</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mutation</span>(<span class="params">arr</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">str1 = arr[<span class="number">0</span>].toLowerCase();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">str2 = arr[<span class="number">1</span>].toLowerCase();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str2.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (str1.indexOf(str2[i]) &lt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">mutation([<span class="string">"hello"</span>, <span class="string">"hey"</span>]);</span></pre></td></tr></table></figure>
<blockquote>
<p>获取字符串的某个字符有两种方法。 第一种是使用 charAt 方法：</p>
</blockquote>
<pre><code>return &apos;cat&apos;.charAt(1); // returns &quot;a&quot;</code></pre><blockquote>
<p>另一种 (在ECMAScript 5中有所介绍) 是把字符串当作一个类似数组的对象，其中的每个字符对应一个数值索引：</p>
</blockquote>
<pre><code>return &apos;cat&apos;[1]; // returns &quot;a&quot;  </code></pre><blockquote>
<p>使用括号访问字符串不可以对其进行删除或添加，因为字符串对应未知的属性并不是可读或配置的。</p>
</blockquote>
<h2 id="13-删除数组中特定值算法挑战"><a href="#13-删除数组中特定值算法挑战" class="headerlink" title="13.删除数组中特定值算法挑战"></a>13.删除数组中特定值算法挑战</h2><p>删除数组中的所有的假值。</p>
<p>在JavaScript中，假值有<code>false</code>、<code>null</code>、<code>0</code>、<code>&quot;&quot;</code>、<code>undefined</code> 和 <code>NaN</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bouncer</span>(<span class="params">arr</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Don't show a false ID to this bouncer.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = arr.filter(<span class="function"><span class="params">item</span> =&gt;</span> !(!item || item === <span class="string">""</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">bouncer([<span class="number">7</span>, <span class="string">"ate"</span>, <span class="string">""</span>, <span class="literal">false</span>, <span class="number">9</span>]);</span></pre></td></tr></table></figure>

<h2 id="14-去除数组中任意多个值算法挑战"><a href="#14-去除数组中任意多个值算法挑战" class="headerlink" title="14.去除数组中任意多个值算法挑战"></a>14.去除数组中任意多个值算法挑战</h2><p>实现一个 destroyer 函数，第一个参数是初始数组，后跟一个或多个参数。从初始数组中删除与这些参数具有相同值的所有元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroyer</span>(<span class="params">arr</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//arguments是保存当前函数所有的参数的类数组对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> argArr = <span class="built_in">arguments</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//遍历参数数组，与初始数组的每个元素进行比较，返回初始数组中不同的元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; argArr.length; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        arr = arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">return</span> argArr[i] !== val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> arr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">destroyer([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>, <span class="number">3</span>);</span></pre></td></tr></table></figure>

<h2 id="15-数组排序并插入值算法挑战"><a href="#15-数组排序并插入值算法挑战" class="headerlink" title="15.数组排序并插入值算法挑战"></a>15.数组排序并插入值算法挑战</h2><p>先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。</p>
<blockquote>
<p>举例：<code>where([1,2,3,4], 1.5)</code> 应该返回<code>1</code>。因为<code>1.5</code>插入到数组<code>[1,2,3,4]</code>后变成<code>[1,1.5,2,3,4]</code>，而<code>1.5</code>对应的索引值就是<code>1</code>。</p>
</blockquote>
<blockquote>
<p>同理，<code>where([20,3,5], 19)</code> 应该返回 <code>2</code>。因为数组会先排序为 <code>[3,5,20]</code>，19插入到数组<code>[3,5,20]</code>后变成<code>[3,5,19,20]</code>，而<code>19</code>对应的索引值就是<code>2</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">where</span>(<span class="params">arr, num</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find my place in this sorted array.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">arr.push(num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">return</span> a-b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   &#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> arr.indexOf(num);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">where([<span class="number">40</span>, <span class="number">60</span>], <span class="number">50</span>);</span></pre></td></tr></table></figure>

<blockquote>
<p>sort() 方法用于对数组的元素进行排序。</p>
</blockquote>
<pre><code>arrayObject.sort(sortby)</code></pre><blockquote>
<p><code>sortby</code>    可选。规定排序顺序。必须是函数。</p>
</blockquote>
<blockquote>
<p><strong>返回值</strong>  对数组的引用。请注意，数组在原数组上进行排序，不生成副本。</p>
</blockquote>
<p>如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p>
<p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p>
<ul>
<li>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</li>
<li>若 a 等于 b，则返回 0。</li>
<li>若 a 大于 b，则返回一个大于 0 的值。</li>
</ul>
<h2 id="16-位移密码算法挑战"><a href="#16-位移密码算法挑战" class="headerlink" title="16. 位移密码算法挑战"></a>16. 位移密码算法挑战</h2><p>下面我们来介绍著名的凯撒密码<code>Caesar cipher</code>，又叫移位密码。</p>
<p>移位密码也就是密码中的字母会按照指定的数量来做移位。</p>
<p>一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔’O’，以此类推。</p>
<p>写一个ROT13函数，实现输入加密字符串，输出解密字符串。</p>
<p>所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，就跳过它们</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rot13</span>(<span class="params">str</span>) </span>&#123; <span class="comment">// LBH QVQ VG!</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> patt1=<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[A-Z]"</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = str.split(<span class="string">""</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span>(patt1.test(arr[i]))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	   <span class="keyword">var</span> temp = arr[i].charCodeAt();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	   temp = temp <span class="number">-13</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	   <span class="keyword">if</span>(temp&lt;<span class="number">65</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	       temp = temp+<span class="number">26</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	   arr[i] = <span class="built_in">String</span>.fromCharCode(temp);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> arr.join(<span class="string">""</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Change the inputs below to test</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">rot13(<span class="string">"SERR PBQR PNZC"</span>);</span></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rot13</span>(<span class="params">str</span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//定义一个数组，用来存放解密后的字符</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> newArr = [];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//遍历参数字符串</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// 非字母形式的字符，直接跳过，存入数组newArr中</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (str.charCodeAt(i) &lt; <span class="number">65</span> || str.charCodeAt(i) &gt; <span class="number">90</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">            newArr.push(str.charAt(i));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">77</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 后13个大写字母，减去13</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            newArr.push(<span class="built_in">String</span>.fromCharCode(str.charCodeAt(i) - <span class="number">13</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// 前13个大写字母，加上13 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            newArr.push(<span class="built_in">String</span>.fromCharCode(str.charCodeAt(i) + <span class="number">13</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> newArr.join(<span class="string">""</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">XTZhu</p>
  <div class="site-description" itemprop="description">learnLess</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">31</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XTZhu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.1.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
