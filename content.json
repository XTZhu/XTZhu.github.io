{"pages":[{"title":"","text":"const jb = { 'A': 1, 'B.A': 2, 'B.B': 3, 'CC.D.E': 4, 'CC.D.F': 5 }; let keysArr = []; let tempArr = []; for (var key in jb) { // alert(key); //json对象的key let tempArr = key.split('.') // alert(jb[key]); //json对象的值 keysArr.push(tempArr) } console.log(keysArr); keysArr.map((a, index) => { if (index === 0)tempArr.push(a) for(let i=0; i","link":"/Obj.js"},{"title":"","text":"function sort(array) { let aCount = new Array(100); let bCount = new Array(100); for (let i = 0; i < 100; i++) { aCount[i] = 0; bCount[i] = 0; }; for (let i = 0; i < array.length; i++) { if (array[i] >= 0) { ++aCount[array[i]]; } else { ++bCount[-array[i]]; } } let index = 0; let temp = new Array(); for (let i = 0; i < 100; i++) { for (let j = 0; j < aCount[i]; j++) { temp[index] = i; index++; } } temp.reverse(); for (let i = 0; i < 100; i++) { for (let j = 0; j < bCount[i]; j++) { temp[index] = -i; index++; } } console.log(temp) } sort([6, 4, -3, 5, -2, -1, 0, 1, -9]);","link":"/sort.js"},{"title":"about","text":"","link":"/about/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"home","text":"","link":"/home/index.html"},{"title":"schedule","text":"","link":"/schedule/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Ajax跨域（转载）","text":"转载自 https://segmentfault.com/a/1190000012469713 http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html http://www.ruanyifeng.com/blog/2016/04/cors.html 什么是同源政策？说起跨域，就必须先了解“同源政策”。浏览器安全的基石是”同源政策”（same-origin policy）。很多开发者都知道这一点，但了解得不全面。 同源政策的含义1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。 最初，它的含义是指，A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓同源指的是”三个相同”。 协议相同 域名相同 端口相同 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。 - http://www.example.com/dir2/other.html：同源 - http://example.com/dir/other.html：不同源（域名不同） - http://v2.www.example.com/dir/other.html：不同源（域名不同） - http://www.example.com:81/dir/other.html：不同源（端口不同）同源政策的目的同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。 设想这样一种情况：A网站是一家银行，用户登录以后，又去浏览其他网站。如果其他网站可以读取A网站的 Cookie，会发生什么？ 很显然，如果 Cookie 包含隐私（比如存款总额），这些信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。 由此可见，”同源政策”是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。 同源政策的限制范围随着互联网的发展，”同源政策”越来越严格。目前，如果非同源，共有三种行为受到限制。 （1） Cookie、LocalStorage 和 IndexDB 无法读取。（2） DOM 无法获得。（3） AJAX 请求不能发送。 在这里我们主要讨论AJAX的跨域问题。 AJAX的跨域同源政策规定，AJAX请求只能发给同源的网址，否则就报错。 除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。 JSONP WebSocket CORS JSONP(现在已经几乎不会再使用JSONP了，所以JSONP了解下即可) jsonp解决跨域问题是一个比较古老的方案(实际中不推荐使用),这里做简单介绍(实际项目中如果要使用JSONP,一般会使用JQ等对JSONP进行了封装的类库来进行ajax请求) 实现原理JSONP之所以能够用来解决跨域方案,主要是因为&lt;script&gt;脚本拥有跨域能力,而JSONP正是利用这一点来实现。具体原理如图 实现流程JSONP的实现步骤大致如下 客户端网页网页通过添加一个&lt;script&gt;元素，向服务器请求JSON数据，这种做法不受同源政策限制 1234567891011121314function addScriptTag(src) { var script = document.createElement('script'); script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;); script.src = src; document.body.appendChild(script);}window.onload = function () { addScriptTag('http://example.com/ip?callback=foo');}function foo(data) { console.log('response data: ' + JSON.stringify(data));}; 请求时,接口地址是作为构建出的脚本标签的src的,这样,当脚本标签构建出来时,最终的src是接口返回的内容 服务端对应的接口在返回参数外面添加函数包裹层 foo({ &quot;test&quot;: &quot;testData&quot; }); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 注意,一般的JSONP接口和普通接口返回数据是有区别的,所以接口如果要做JSONO兼容,需要进行判断是否有对应callback关键字参数,如果有则是JSONP请求,返回JSONP数据,否则返回普通数据 使用注意: 基于JSONP的实现原理,所以JSONP只能是“GET”请求,不能进行较为复杂的POST和其它请求,所以遇到那种情况,就得参考下面的CORS解决跨域了(所以如今它也基本被淘汰了) WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 下面是一个例子，浏览器发出的WebSocket请求的头信息 GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Origin: http://example.com上面代码中，有一个字段是Origin，表示该请求的请求源（origin），即发自哪个域名。 正是因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= Sec-WebSocket-Protocol: chatCORSCORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 基本上目前所有的浏览器都实现了CORS标准,其实目前几乎所有的浏览器ajax请求都是基于CORS机制的,只不过可能平时前端开发人员并不关心而已(所以说其实现在CORS解决方案主要是考虑后台该如何实现的问题)。 这里也整理了一个实现原理图(简化版) 如何判断是否是简单请求?浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求 （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/- form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 待续。。","link":"/2019/04/18/Ajax%E8%B7%A8%E5%9F%9F/"},{"title":"Git 远程分支相关操作","text":"git 拉取远程分支到本地1234567891011121314git init// 添加远程仓库连接git remote add origin git@github.com:XXXX/nothing2.git// 把远程分支拉到本地git fetch origin [dev]（dev为远程仓库的分支名）// 在本地创建分支dev并切换到该分支git checkout -b [dev] (本地分支名称) [origin/dev](远程分支名称)// 把某个分支上的内容都拉取到本地git pull origin [dev] (远程分支名称) 如何解决failed to push some refs to git123456789// 尝试提交到远程master分支上 出错git push -u origin master // failed to push some refs to 'git@github.com: xxx/xxx.git'// 主要是因为README.md文件和本地文件有差异// 通过该命令进行代码合并： [pull = fetch + merge]git pull --rebase origin master// 重新push代码git push -u origin master 聊一下git pull rebase 参考文章","link":"/2020/04/07/Git-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"},{"title":"Hello world","text":"Hello world stay hungry， stay foolish. 求知若饥 虚心若愚 这里是pipipig的无名小站！谢谢你来这里。","link":"/2019/02/10/Hello%20world/"},{"title":"Rest 参数与 Spread 操作符","text":"参考资料：Rest 参数与 Spread 操作符 Rest 参数与 Spread 操作符在 JavaScript 中，很多内建函数都支持传入任意个参数。例如： Math.max(arg1, arg2, …, argN) —— 返回入参中的最大值。 Object.assign(dest, src1, …, srcN) —— 依次合并 src1..N 的属性到 dest。…等等。 剩余参数（Rest)在 JavaScript 中，无论函数定义了多少个形参，你都可以传入任意个实参进行调用。 12345function sum(a, b) { return a + b;}alert( sum(1, 2, 3, 4, 5) ); 虽然这里不会因为传入“过多”的参数而报错，但是多余的参数也不会起任何作用，函数只会返回前两个参数相加的结果。 针对上例，我们可以在定义函数时使用 Rest 参数，Rest 参数的操作符表示为3个点 ...。直白地讲，它的意思就是把剩余的参数都放到一个数组中。 两个例子： 1234567891011function sumAll(...args) { // 数组变量名为 args let sum = 0; for (let arg of args) sum += arg; return sum;}alert( sumAll(1) ); // 1alert( sumAll(1, 2) ); // 3alert( sumAll(1, 2, 3) ); // 6 1234567891011function showName(firstName, lastName, ...titles) { alert( firstName + ' ' + lastName ); // Julius Caesar // titles 数组中包含了剩余的参数 // 也就是有 titles = [&quot;Consul&quot;, &quot;Imperator&quot;] alert( titles[0] ); // Consul alert( titles[1] ); // Imperator alert( titles.length ); // 2}showName(&quot;Julius&quot;, &quot;Caesar&quot;, &quot;Consul&quot;, &quot;Imperator&quot;); Rest 参数必须放到参数列表的末尾 12function f(arg1, ...rest, arg2) { // error} 在 JavaScript 引入 Rest 参数之前，无论入参数是多是少，想获取所有的入参只能使用 arguments。 即使 arguments 是一个类数组且可遍历的变量，但它终究不是数组。它没有数组原型链上的函数，我们没法直接调用诸如 arguments.map(…) 等这样的函数。 现在用rest代替更好。 箭头函数是没有 “arguments” 的 而且也没有this 展开操作符操作符（Spread）例子：内建函数 Math.max 会返回参数中最大的值： 1234alert( Math.max(3, 5, 1) ); // 5let arr = [3, 5, 1];alert( Math.max(arr) ); // NaN Math.max 期待你传入一系列的数值型参数 当在函数调用时使用Spread 操作符 ...arr，它会把可迭代的对象 arr 展开为参数列表。 1234let arr1 = [1, -2, 3, 4];let arr2 = [8, 3, -8, 1];alert( Math.max(...arr1, ...arr2) ); // 8 可以传递多个被展开的迭代对象 1234let arr1 = [1, -2, 3, 4];let arr2 = [8, 3, -8, 1];alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25 在普通的参数间使用展开操作符 123456let arr = [3, 5, 1];let arr2 = [8, 9, 15];let merged = [0, ...arr, 2, ...arr2]; //使用 Spread 操作符合并数组alert(merged); // 0,3,5,1,2,8,9,15（0，然后是 arr 的值，2，然后是 arr2 的值） 123let str = &quot;Hello&quot;; //使用 Spread 操作符把字符串展开为字符数组alert( [...str] ); // H,e,l,l,o JavaScript 内部使用了遍历器来实现 Spread 操作符，因此使用 Spread 操作符展开对象与使用 for..of 遍历该对象是一致的。 所以，针对一个字符串，for..of会逐位返回该字符串中的字符，...str1 也同理会得到&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;这样的结果。再将上一步所得的字符串序列传入数组初始化操作符 [...str]，一个字符数组就这样生成了。 我们还可以使用 Array.from 实现上述功能，因为该操作符会将可遍历对象（如字符串）转换为数组： 1234let str = &quot;Hello&quot;;// Array.from 会将可遍历对象转为数组alert( Array.from(str) ); // H,e,l,l,o //运行结果与 [...str] 结果一致。 不过需要注意的是使用 Array.from(obj) 和使用 […obj] 还是存在细微差别：Array.from 同时适用于类数组对象和可遍历对象。Spread 操作符只能操作可遍历对象。因此，若希望把一些“东西”转为数组，使用 Array.from 将更为通用。 小结当我们在代码中遇到 “…” 时，它不是 Rest 参数就是 Spread 操作符。 我们可以使用下列方法区分二者： 若 … 出现在函数的参数列表，那它表示的就是 Rest 参数，它会把函数多余的实参收集到一个数组中。 若 … 出现在函数调用或类似的表达式中，那它就是 Spread 操作符，它会把一个数组展开为逗号分隔的元素列表。 使用场景： Rest 参数用于创建可接收任意个参数的函数。 Spread 操作符可以在函数调用传参时，把含有参数的数组展开为函数需要的参数列表形式。 这两个操作符的出现方便了我们在参数数组和参数列表间来回转换。 “旧式”的 arguments（类数组对象）也依然能够帮助我们获取函数调用时的所有参数。","link":"/2019/05/08/Rest-%E5%8F%82%E6%95%B0%E4%B8%8E-Spread-%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"title":"TCP三次握手与四次挥手","text":"参考资料：https://blog.csdn.net/sinat_36629696/article/details/80740678https://blog.csdn.net/qq_38950316/article/details/81087809 TCP协议TCP协议全称: 传输控制协议, 顾名思义, 就是要对数据的传输进行一定的控制.我们来分析分析每部分的含义和作用 源端口号/目的端口号: 表示数据从哪个进程来, 到哪个进程去. 32位序号: 序列号seq：占4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编号由本地随机产生；给字节编上序号后，就给每一个报文段指派一个序号；序列号seq就是这个报文段中的第一个字节的数据编号 32位确认号： 确认号ack：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序列号表示报文段携带数据的第一个字节的编号；而确认号指的是期望接收到下一个字节的编号；因此当前报文段最后一个字节的编号+1即为确认号。 4位首部长度: 表示该tcp报头有多少个4字节(32个bit) 6位保留: 顾名思义, 先保留着, 以防万一 6位标志位 URG: 标识紧急指针是否有效 ACK: 标识确认序号是否有效 PSH: 用来提示接收端应用程序立刻将数据从tcp缓冲区读走 RST: 要求重新建立连接. 我们把含有RST标识的报文称为复位报文段 SYN: 请求建立连接. 我们把含有SYN标识的报文称为同步报文段 FIN: 通知对端, 本端即将关闭. 我们把含有FIN标识的报文称为结束报文段 16位窗口大小: 16位检验和: 由发送端填充, 检验形式有CRC校验等. 如果接收端校验不通过, 则认为数据有问题. 此处的校验和不光包含TCP首部, 也包含TCP数据部分. 16位紧急指针: 用来标识哪部分数据是紧急数据.选项和数据暂时忽略 PS：ACK、SYN和FIN这些大写的单词表示标志位，其值要么是1，要么是0；ack、seq小写的单词表示序号 字段 含义 URG 紧急指针是否有效。为1，表示某一位需要被优先处理 ACK 确认号是否有效，一般置为1。 PSH 提示接收端应用程序立即从TCP缓冲区把数据读走。 RST 对方要求重新建立连接，复位。 SYN 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1 FIN 希望断开连接。 三次握手TCP的连接建立是一个三次握手过程，目的是为了通信双方确认开始序号，以便后续主要步骤如下：第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 四次挥手TCP终止连接的四次挥手过程如下： 客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入 FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。 服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 补充引用链接：https://www.cnblogs.com/zmlctt/p/3690998.htmlhttps://mp.weixin.qq.com/s/L-eSLMFQGVmVJzmqHgFHtw 常见面试题 为什么连接的时候是三次握手，关闭的时候却是四次握手？ 因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？ 虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。 为什么不能用两次握手进行连接？ 3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 如果已经建立了连接，但是客户端突然出现故障了怎么办？ TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。","link":"/2019/04/08/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"},{"title":"ajax工作原理","text":"ajax工作原理 参考资料：http://www.cnblogs.com/mingmingruyuedlut/archive/2011/10/18/2216553.html AJAX的名字ajax 的全称是Asynchronous JavaScript and XML，其中，Asynchronous 是异步的意思，它有别于传统web开发中采用的同步的方式。 异步和同步异步 面向字符（单位：比特） 将byte分成小组进行传输（一般8个字符) 小组的（头/尾）分别有（开始位/结束位） 传输过程中发送方和接收方时钟不要求一致 发送方可以在任何时刻发送，而接收方并不知道数据什么时候到达 开始位：它通知接收方数据已经到达了，这就给了接收方响应、接收 和缓存数据比特的时间 同步 面向比特（单位：数据帧/帧） 要求：接收方和发送方的时钟保持一致 同步的比特分组要大得多 不单独发送，而是组合发送（发送帧） 数据帧： 开始部分： 一个独特的比特（一组同步字符） 作用：通知帧到达（相当于起始位），确保接收方的采样速度和比特的到达速度一致，保持同步。 中间部分 尾部：帧结束标记 作用： 表示在下一帧开始之前没有别的数据了 对比 同步传输通常要比异步传输快速得多。 接收方不必对每个字符进行开始和停止的操作。一旦检测到帧同步字符，它就在接下来的数据到达时接收它们 同步传输的开销也比较少 一个典型的帧可能有500字节（即4000比特）的数据，其中可能只包含100比特的开销。这时，增加的比特位使传输的比特总数增加2.5%，这与异步传输中25 %的增值要小得多 随着数据帧中实际数据比特位的增加，开销比特所占的百分比将相应地减少 但是，数据比特位越长，缓存数据所需要的缓冲区也越大，这就限制了一个帧的大小 帧越大，它占据传输媒体的连续时间也越长。在极端的情况下，这将导致其他用户等得太久 了解了同步和异步的概念之后，大家应该对ajax为什么可以提升用户体验应该比较清晰了，它是利用异步请求方式的。 打个比方，如果现在你家里所在的小区因 某种情况而面临停水，现在有关部门公布了两种方案，一是完全停水8个小时，在这8个小时内完全停水，8个小时后恢复正常。二是不完全停水10个小时，在这10个小时内水没有完全断，只是流量比原来小了很多，在10个小时后恢复正常流量，那么，如果是你你会选择哪种方式呢？显然是后者。 ajax所包含的技术 使用CSS和XHTML来表示。 使用DOM模型来交互和动态显示。 使用XMLHttpRequest来和服务器进行异步通信。 使用javascript来绑定和调用。 在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。 ajax原理和XmlHttpRequest对象Ajax的原理： 通过XmlHttpRequest对象来向服务器发异步请求 从服务器获得数据 用javascript来操作DOM而更新页面。 这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 XMLHttpRequest对象的属性它的属性有： onreadystatechange 每次状态改变所触发事件的事件处理程序。 responseText 从服务器进程返回数据的字符串形式。 responseXML 从服务器进程返回的DOM兼容的文档数据对象。 status 从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪） status Text 伴随状态码的字符串信息 readyState 对象状态值 0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法） 1 (初始化) 对象已建立，尚未调用send方法 2 (发送数据) send方法已调用，但是当前的状态及http头未知 3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误 4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据 创建XMLHttpRequest对象的方法由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest对象的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142function CreateXmlHttp() { //非IE浏览器创建XmlHttpRequest对象 if (window.XmlHttpRequest) { xmlhttp = new XmlHttpRequest(); } //IE浏览器创建XmlHttpRequest对象 if (window.ActiveXObject) { try { xmlhttp = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } catch (e) { try { xmlhttp = new ActiveXObject(&quot;msxml2.XMLHTTP&quot;); } catch (ex) { } } }}function Ustbwuyi() { var data = document.getElementById(&quot;username&quot;).value; CreateXmlHttp(); if (!xmlhttp) { alert(&quot;创建xmlhttp对象异常！&quot;); return false; } xmlhttp.open(&quot;POST&quot;, url, false); xmlhttp.onreadystatechange = function () { if (xmlhttp.readyState == 4) { document.getElementById(&quot;user1&quot;).innerHTML = &quot;数据正在加载...&quot;; if (xmlhttp.status == 200) { document.write(xmlhttp.responseText); } } } xmlhttp.send();} 如上所示，函数首先检查XMLHttpRequest的整体状态并且保证它已经完成（readyStatus=4），即数据已经发送完毕。然后根据服务器的设定询问请求状态，如果一切已经就绪（status=200），那么就执行下面需要的操作。 对于XmlHttpRequest的两个方法，open和send，其中open方法指定了： a、向服务器提交数据的类型，即post还是get。 b、请求的url地址和传递的参数。 c、传输方式，false为同步，true为异步。默认为true。如果是异步通信方式(true)，客户机就不等待服务器的响应；如果是同步方式(false)，客户机就要等到服务器返回消息后才去执行其他操作。我们需要根据实际需要来指定同步方式，在某些页面中，可能会发出多个请求，甚至是有组织有计划有队形大规模的高强度的request，而后一个是会覆盖前一个的，这个时候当然要指定同步方式。 Send方法用来发送请求。 ajax的原理我们可以看出，XMLHttpRequest是完全用来向服务器发出一个请求的，它的作用也局限于此，但它的作用是整个ajax实现的关键，因为ajax无非是两个过程，发出请求和响应请求。并且它完全是一种客户端的技术。而XMLHttpRequest正是处理了服务器端和客户端通信的问题所以才会如此的重要。 我们可以把服务器端看成一个数据接口，它返回的是一个纯文本流，当然，这个文本流可以是XML格式，可以是Html，可以是Javascript代码，也可以只是一个字符串。这时候，XMLHttpRequest向服务器端请求这个页面，服务器端将文本的结果写入页面，这和普通的web开发流程是一样的，不同的是，客户端在异步获取这个结果后，不是直接显示在页面，而是先由javascript来处理，然后再显示在页面。至于现在流行的很多ajax控件，比如magicajax等，可以返回DataSet等其它数据类型，只是将这个过程封装了的结果，本质上他们并没有什么太大的区别。 ajax的优点 最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。 使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。 可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。 基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。 ajax的缺点 ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。这是ajax所带来的一个比较严重的问题，因为用户往往是希望能够通过后退来取消前一次操作的。解决办法：用过Gmail的知道，Gmail下面采用的ajax技术解决了这个问题，在Gmail下面是可以后退的，但是，它也并不能改变ajax的机制，它只是采用的一个比较笨但是有效的办法，即用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。 （例如，当用户在Google Maps中单击后退时，它在一个隐藏的IFRAME中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态。）但是，虽然说这个问题是可以解决的，但是它所带来的开发成本是非常高的，和ajax框架所要求的快速开发是相背离的。这是ajax所带来的一个非常严重的问题。 安全问题技术同时也对IT企业带来了新的安全威胁，ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远端服务器上建立新的攻击。还有ajax也难以避免一些已知的安全弱点，诸如跨站点脚步攻击、SQL注入攻击和基于credentials的安全漏洞等。 对搜索引擎的支持比较弱。 破坏了程序的异常机制。至少从目前看来，像ajax.dll，ajaxpro.dll这些ajax框架是会破坏程序的异常机制的。关于这个问题，我曾经在开发过程中遇到过，但是查了一下网上几乎没有相关的介绍。后来我自己做了一次试验，分别采用ajax和传统的form提交的模式来删除一条数据……给我们的调试带来了很大的困难。 另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷。例如，我给你一个url地址，如果采用了ajax技术，也许你在该url地址下面看到的和我在这个url地址下看到的内容是不同的。这个和资源定位的初衷是相背离的。 一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。","link":"/2019/05/09/ajax%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"title":"css文字省略","text":"单行文字省略123text-overflow: ellipsis;overflow: hidden;white-space: nowrap; 多行文字实现(有浏览器兼容性问题)1234overflow: hidden;-webkit-line-clamp: 3; -webkit-box-orient: vertical;display: -webkit-box;","link":"/2020/03/19/css%E6%96%87%E5%AD%97%E7%9C%81%E7%95%A5/"},{"title":"java8的JVM持久代--何去何从？","text":"原帖地址： https://blog.csdn.net/yechaodechuntian/article/details/40341975 基础知识JVM只不过是运行在你系统上的另一个进程而已，这一切的魔法始于一个java命令。正如任何一个操作系统进程那样，JVM也需要内存来完成它的运行时操作。记住——JVM本身是硬件的一层软件抽象，在这之上才能够运行Java程序，也才有了我们所吹嘘的平台独立性以及WORA（一次编写，处处运行）。 快速过一遍JVM的内存结构正如虚拟机规范所说的那样，JVM中的内存分为5个虚拟的区域。 堆 方法区（非堆） JVM栈 本地栈 PC寄存器 堆 你的Java程序中所分配的每一个对象都需要存储在内存里。堆是这些实例化的对象所存储的地方。是的——都怪new操作符，是它把你的Java堆都占满了的！ 它由所有线程共享 当堆耗尽的时候，JVM会抛出java.lang.OutOfMemoryError 异常 堆的大小可以通过JVM选项-Xms和-Xmx来进行调整 堆被分为： Eden区 —— 新对象或者生命周期很短的对象会存储在这个区域中，这个区的大小可以通过-XX:NewSize和-XX:MaxNewSize参数来调整。新生代GC（垃圾回收器）会清理这一区域。 Survivor区 —— 那些历经了Eden区的垃圾回收仍能存活下来的依旧存在引用的对象会待在这个区域。这个区的大小可以由JVM参数-XX:SurvivorRatio来进行调节。 老年代 —— 那些在历经了Eden区和Survivor区的多次GC后仍然存活下来的对象（当然了，是拜那些挥之不去的引用所赐）会存储在这个区里。这个区会由一个特殊的垃圾回收器来负责。年老代中的对象的回收是由老年代的GC（major GC）来进行的。 方法区 也被称为非堆区域（在HotSpot JVM的实现当中） 它被分为两个主要的子区域 持久代这个区域会存储包括类定义，结构，字段，方法（数据及代码）以及常量在内的类相关数据。它可以通过-XX:PermSize及-XX:MaxPermSize来进行调节。如果它的空间用完了，会导致java.lang.OutOfMemoryError: PermGen space的异常。 代码缓存这个缓存区域是用来存储编译后的代码。编译后的代码就是本地代码（硬件相关的），它是由JIT（Just In Time)编译器生成的，这个编译器是Oracle HotSpot JVM所特有的。 JVM栈 和Java类中的方法密切相关 它会存储局部变量以及方法调用的中间结果及返回值 Java中的每个线程都有自己专属的栈，这个栈是别的线程无法访问的。 可以通过JVM选项-Xss来进行调整 本地栈 用于本地方法（非Java代码） 按线程分配 PC寄存器 特定线程的程序计数器 包含JVM正在执行的指令的地址（如果是本地方法的话它的值则未定义） 好吧，这就是JVM内存分区的基础知识了。现在再说说持久代这个话题吧。 那么持久代上哪去了？事实上，持久代已经被彻底删除了，取代它的是另一个内存区域也被称为元空间。 元空间 —— 快速入门 它是本地堆内存中的一部分 它可以通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize来进行调整 当到达XX:MetaspaceSize所指定的阈值后会开始进行清理该区域 如果本地空间的内存用尽了会收到java.lang.OutOfMemoryError: Metadata space的错误信息。 和持久代相关的JVM参数-XX:PermSize及-XX:MaxPermSize将会被忽略掉。 当然了，这只是冰山一角。想要更深入地了解JVM，最好的资料莫过于它自己的虚拟机规范了！","link":"/2019/02/23/java8%E7%9A%84JVM%E6%8C%81%E4%B9%85%E4%BB%A3%E2%80%94%E2%80%94%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E%EF%BC%9F/"},{"title":"java到底是解释性语言还是编译型语言？","text":"Java这个语言很非凡。一、你可以说它是编译型的。因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。 二、你可以说它是解释型的。因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释的了。 三、但是，现在的JVM为了效率，都有一些JIT优化。它又会把.class的二进制代码编译为本地的代码直接运行，所以，又是编译的。 像C、C++ 他们经过一次编译之后直接可以编译成操作系统了解的类型，可以直接执行的 所以他们是编译型的语言。没有经过第二次的处理 而Java不一样他首先由编译器编译成.class类型的文件，这个是java自己类型的文件 然后在通过虚拟机(JVM)从.class文件中读一行解释执行一行，所以他是解释型的语言，而由于java对于多种不同的操作系统有不同的JVM所以 Java实现了真正意义上的跨平台！ 请观看下面两张图 了解一下Java的虚拟机机制： (1)java语言的编译–&gt;解释—&gt;执行过程 (2)java的虚拟机 今天听到同事在讨论java是哪种类型的语言（编译型、解释型），以前稍微有些接触，但是概念比较模糊，为了不至于让别人的思想左右自己，所以查了些资料，找到了很多热心网友给出的答案，终于有些明白。这里先给出编译型语言和解释型语言的定义。 定义：编译型语言：把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。解释型语言：把做好的源程序翻译一句，然后执行一句，直至结束！ 区别：编译型语言，执行速度快、效率高；依靠编译器、跨平台性差些。解释型语言，执行速度慢、效率低；依靠解释器、跨平台性好。 个人认为，java是解释型的语言，因为虽然java也需要编译，编译成.class文件，但是并不是机器可以识别的语言，而是字节码，最终还是需要 jvm的解释，才能在各个平台执行，这同时也是java跨平台的原因。所以可是说java即是编译型的，也是解释型，但是假如非要归类的话，从概念上的定义，恐怕java应该归到解释型的语言中。 附：编译型的语言包括：C、C++、Delphi、Pascal、Fortran解释型的语言包括：Java、Basic、javascript","link":"/2019/04/16/java%E5%88%B0%E5%BA%95%E6%98%AF%E8%A7%A3%E9%87%8A%E6%80%A7%E8%AF%AD%E8%A8%80%E8%BF%98%E6%98%AF%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%9F/"},{"title":"null和undefined与NaN","text":"参考资料：undefined与null的区别 参考资料：47.描述以下变量的区别：null，undefined或undeclared？ 大多数计算机语言，有且仅有一个表示”无”的值，比如，C语言的NULL，Java语言的null，Python语言的None，Ruby语言的nil。 有点奇怪的是，JavaScript语言居然有两个表示”无”的值：undefined和null。这是为什么？ 相似性在javaScript中，将一个变量赋值为undefined或null，老实说，几乎没区别。 undefined和null在if语句中，都会被自动转为false，相等运算符甚至直接报告两者相等。 1234567891011if (!undefined) console.log('undefined is false'); // undefined is falseif (!null) console.log('null is false'); // null is falsevar a = undefined;var b = null;a == b; //truea === b; //false 既然undefined和null的含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加JavaScript的复杂度，令初学者困扰吗？Google公司开发的JavaScript语言的替代品Dart语言，就明确规定只有null，没有undefined！ 原来，这与JavaScript的历史有关。1995年JavaScript诞生时，最初像Java一样，只设置了null作为表示”无”的值。 根据C语言的传统，null被设计成可以自动转为0。 12Number(null) // 05 + null // 5 但是，JavaScript的设计者Brendan Eich，觉得这样做还不够，有两个原因。 首先，null像在Java里一样，被当成一个对象。但是，JavaScript的数据类型分成原始类型（primitive）和合成类型（complex）两大类，Brendan Eich觉得表示”无”的值最好不是对象。 其次，JavaScript的最初版本没有包括错误处理机制，发生数据类型不匹配时，往往是自动转换类型或者默默地失败。Brendan Eich觉得，如果null自动转为0，很不容易发现错误。 因此，Brendan Eich又设计了一个undefined。 最初设计JavaScript的最初版本是这样区分的：null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 12Number(undefined) // NaN5 + undefined // NaN 目前的用法但是，上面这样的区分，在实践中很快就被证明不可行。目前，null和undefined基本是同义的，只有一些细微的差别. null表示”没有对象”，即该处不应该有值。典型用法是： 用来初始化一个变量，这个变量可能被赋值为一个对象。 用来和一个已经初始化的变量比较，这个变量可以是也可以不是一个对象。 当函数的参数期望是对象时，被用作参数传入。 当函数的返回值期望是对象时，被用作返回值传出。 作为对象原型链的终点。 1Object.getPrototypeOf(Object.prototype) // null undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： 变量被声明了，但没有赋值时，就等于undefined。 调用函数时，应该提供的参数没有提供，该参数等于undefined。 对象没有赋值的属性，该属性的值为undefined。 函数没有返回值时，默认返回undefined。 1234567891011var i;i // undefinedfunction f(x){console.log(x)}f() // undefinedvar o = new Object();o.p // undefinedvar x = f();x // undefined 对已声明但未初始化的和未声明的变量执行typeof，都返回”undefined”。null表示一个空对象指针，typeof操作会返回”object”。一般不显式的把变量的值设置为undefined，但null相反，对于将要保存对象的变量，应明确的让该变量保存null值。 该如何检测它们？null：表示无值；undefined：表示一个未声明的变量，或已声明但没有赋值的变量，或一个并不存在的对象属性。 JS中如何判断undefined?==运算符将两者看作相等。如果要区分两者，要使用===或typeof运算符。 以下是不正确的用法： 12345var exp = undefined;if (exp == undefined) { alert(&quot;undefined&quot;);} exp为null时，也会得到与undefined相同的结果，虽然null和undefined不一样。 注意：要同时判断undefined和null时可使用本法。 typeof返回的是字符串，有六种可能：”number”、”string”、”boolean”、”object”、”function”、”undefined”。 以下是正确的用法： 12345var exp = undefined;if(typeof(exp) == &quot;undefined&quot;) { alert(&quot;undefined&quot;);} JS中如何判断null？以下是不正确的用法： 12345var exp = null;if(exp == null) { alert(&quot;is null&quot;);} exp为undefined时，也会得到与null相同的结果，虽然null和undefined不一样。 注意：要同时判断null和undefined时可使用本法。 12345var exp=null;if(!exp) { alert(&quot;is null&quot;);} 如果exp为undefined或者数字零，也会得到与null相同的结果，虽然null和二者不一样。 注意：要同时判断null、undefined和数字零时可使用本法。 12345var exp = null;if(typeof(exp) == &quot;null&quot;) { alert(&quot;is null&quot;);} 为了向下兼容，exp为null时，typeof总返回object。这种方式也不太好。 以下是正确的用法： 12345var exp = null;if(!exp&amp;&amp;typeof(exp) != &quot;undefined&quot; &amp;&amp; exp != 0) { alert(&quot;is null&quot;);} 检测对象是否为空对象12345678910/** 检测对象是否是空对象(不包含任何可读属性)。* 方法既检测对象本身的属性，也检测从原型继承的属性(因此没有使hasOwnProperty)。*/function isEmpty(obj) { for (var name in obj) { return false; } return true;}; 这里所说的空对象，到底是 {} 还是 null 12345678910111213141516171819var a = {};a.name = 'realwall';console.log(isEmpty(a)); //falseconsole.log(isEmpty({})); //trueconsole.log(isEmpty(null)); //true //注意参数为null时无语法错误哦，即虽然不能对null空指针对象添加属性，但可以使用for in 语句/** 检测对象是否是空对象(不包含任何可读属性)。* 方法只既检测对象本身的属性，不检测从原型继承的属性。*/function isOwnEmpty(obj){ for(var name in obj){ if(obj.hasOwnProperty(name)){ return false; } } return true;}; {}与null的区别： 1234567var a = {};var b = null; a.name = 'realwall';b.name = 'jim'; //这里会报错，b为空指针对象，不能像普通对象一样直接添加属性。b = a;b.name = 'jim'; //此时 a 和 b 指向同一个对象。a.name, b.name 均为'jam'","link":"/2019/05/07/null%E5%92%8Cundefined%E4%B8%8ENaN/"},{"title":"lodash的_.find()","text":"_.find() api文档“集合” 方法(“Collection” Methods) .find(collection, [predicate=.identity], [fromIndex=0]) 遍历 collection（集合）元素，返回 predicate（断言函数）第一个返回真值的第一个元素。predicate（断言函数）调用3个参数： (value, index|key, collection)。 添加版本 0.1.0 参数 collection (Array|Object): 一个用来迭代的集合。 [predicate=_.identity] (Array|Function|Object|string): 每次迭代调用的函数。 [fromIndex=0] (number): 开始搜索的索引位置。 返回 (*): 返回匹配元素，否则返回 undefined。 例子1234567891011121314151617181920var users = [ { 'user': 'barney', 'age': 36, 'active': true }, { 'user': 'fred', 'age': 40, 'active': false }, { 'user': 'pebbles', 'age': 1, 'active': true }];_.find(users, function(o) { return o.age &lt; 40; });// =&gt; object for 'barney'// The `_.matches` iteratee shorthand._.find(users, { 'age': 1, 'active': true });// =&gt; object for 'pebbles'// The `_.matchesProperty` iteratee shorthand._.find(users, ['active', false]);// =&gt; object for 'fred'// The `_.property` iteratee shorthand._.find(users, 'active');// =&gt; object for 'barney' 在线demo","link":"/2020/04/07/lodash%E7%9A%84-find/"},{"title":"px,em,rem区别介绍","text":"菜鸟教程原文 pxpx像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 PX特点 IE无法调整那些使用px作为单位的字体大小； 国外的大部分网站能够调整的原因在于其使用了em或rem作为字体单位； Firefox能够调整px和em，rem，但是96%以上的中国网民使用IE浏览器(或内核)。 emem是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 em特点 em的值并不是固定的； em会继承父级元素的字体大小。 注意：任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。所以我们在写CSS的时候，需要注意两点： body选择器中声明Font-size=62.5%； 将你的原来的px数值除以10，然后换上em作为单位； 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。 也就是避免1.2 * 1.2= 1.44的现象。比如说你在#content中声明了字体大小为1.2em，那么在声明p的字体大小时就只能是 1em，而不是1.2em, 因为此em非彼em，它因继承#content的字体高而变为了1em=12px。 remrem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。下面就是一个例子： 1p {font-size:14px; font-size:.875rem;} 注意： 选择使用什么字体单位主要由你的项目来决定，如果你的用户群都使用最新版的浏览器，那推荐使用rem，如果要考虑兼容性，那就使用px,或者两者同时使用。 px 与 rem 的选择？对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用px即可 。 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备。 参考资料","link":"/2020/04/09/px-em-rem%E5%8C%BA%E5%88%AB%E4%BB%8B%E7%BB%8D/"},{"title":"react生命周期（转载）","text":"转载自： 详解React生命周期(包括react16版) 生命周期图谱 React 中文站-React.Component React v16.0前的生命周期其实大部分团队不见得会跟进升到16版本，所以16前的生命周期还是很有必要掌握的，何况16也是基于之前的修改 第一个是组件初始化(initialization)阶段也就是以下代码中类的构造方法( constructor() ),Test类继承了react Component这个基类，也就继承这个react的基类，才能有render(),生命周期等方法可以使用，这也说明为什么函数组件不能使用这些方法的原因。 super(props)用来调用基类的构造方法( constructor() ), 也将父组件的props注入给子组件，供子组件读取(组件中props只读不可变，state可变)。而constructor()用来做一些组件的初始化工作，如定义this.state的初始内容。 1234567import React, { Component } from 'react';class Test extends Component { constructor(props) { super(props); }} 第二个是组件的挂载(Mounting)阶段此阶段分为componentWillMount，render，componentDidMount三个时期。 componentWillMount: 在组件挂载到DOM前调用，且只会被调用一次，在这边调用this.setState不会引起组件重新渲染，也可以把写在这边的内容提前到constructor()中，所以项目中很少用。 render: 根据组件的props和state（无两者的重传递和重赋值，论值是否有变化，都可以引起组件重新render） ，return 一个React元素（描述组件，即UI），不负责组件实际渲染工作，之后由React自身根据此元素去渲染出页面DOM。render是纯函数（Pure function：函数的返回结果只依赖于它的参数；函数执行过程里面没有副作用），不能在里面执行this.setState，会有改变组件状态的副作用。 componentDidMount: 组件挂载到DOM后调用，且只会被调用一次 第三个是组件的更新(update)阶段在讲述此阶段前需要先明确下react组件更新机制。setState引起的state更新或父组件重新render引起的props更新，更新后的state和props相对之前无论是否有变化，都将引起子组件的重新render。详细可看这篇文章 造成组件更新有两类（三种）情况： 1.父组件重新render 父组件重新render引起子组件重新render的情况有两种，内容及代码修引自xiaoyann的回答 a. 直接使用,每当父组件重新render导致的重传props，子组件将直接跟着重新渲染，无论props是否有变化。可通过shouldComponentUpdate方法优化。 12345678910class Child extends Component { shouldComponentUpdate(nextProps){ // 应该使用这个方法，否则无论props是否有变化都将会导致组件跟着重新渲染 if(nextProps.someThings === this.props.someThings){ return false } } render() { return &lt;div&gt;{this.props.someThings}&lt;/div&gt; }} b.在componentWillReceiveProps方法中，将props转换成自己的state 1234567891011121314class Child extends Component { constructor(props) { super(props); this.state = { someThings: props.someThings }; } componentWillReceiveProps(nextProps) { // 父组件重传props时就会调用这个方法 this.setState({someThings: nextProps.someThings}); } render() { return &lt;div&gt;{this.state.someThings}&lt;/div&gt; }} 根据官网的描述 在该函数(componentWillReceiveProps)中调用 this.setState() 将不会引起第二次渲染。 是因为componentWillReceiveProps中判断props是否变化了，若变化了，this.setState将引起state变化，从而引起render，此时就没必要再做第二次因重传props引起的render了，不然重复做一样的渲染了。 2.组件本身调用setState，无论state有没有变化。可通过shouldComponentUpdate方法优化 12345678910111213141516171819202122232425class Child extends Component { constructor(props) { super(props); this.state = { someThings:1 } } shouldComponentUpdate(nextStates){ // 应该使用这个方法，否则无论state是否有变化都将会导致组件重新渲染 if(nextStates.someThings === this.state.someThings){ return false } } handleClick = () =&gt; { // 虽然调用了setState ，但state并无变化 const preSomeThings = this.state.someThings this.setState({ someThings: preSomeThings }) } render() { return &lt;div onClick = {this.handleClick}&gt;{this.state.someThings}&lt;/div&gt; }} 此阶段分为componentWillReceiveProps，shouldComponentUpdate，componentWillUpdate，render，componentDidUpdate componentWillReceiveProps(nextProps) 此方法只调用于props引起的组件更新过程中，参数nextProps是父组件传给当前组件的新props。但父组件render方法的调用不能保证重传给当前组件的props是有变化的，所以在此方法中根据nextProps和this.props来查明重传的props是否改变，以及如果改变了要执行啥，比如根据新的props调用this.setState出发当前组件的重新render shouldComponentUpdate(nextProps, nextState) 此方法通过比较nextProps，nextState及当前组件的this.props，this.state，返回true时当前组件将继续执行更新过程，返回false则当前组件更新停止，以此可用来减少组件的不必要渲染，优化组件性能。 ps：这边也可以看出，就算componentWillReceiveProps()中执行了this.setState，更新了state，但在render前（如shouldComponentUpdate，componentWillUpdate），this.state依然指向更新前的state，不然nextState及当前组件的this.state的对比就一直是true了。 componentWillUpdate(nextProps, nextState) 此方法在调用render方法前执行，在这边可执行一些组件更新发生前的工作，一般较少用。 render render方法在上文讲过，这边只是重新调用。 componentDidUpdate(prevProps, prevState) 此方法在组件更新后被调用，可以操作组件更新的DOM，prevProps和prevState这两个参数指的是组件更新前的props和state 卸载阶段此阶段只有一个生命周期方法：componentWillUnmount componentWillUnmount 此方法在组件被卸载前调用，可以在这里执行一些清理工作，比如清楚组件中使用的定时器，清楚componentDidMount中手动创建的DOM元素等，以避免引起内存泄漏。 React v16.4 的生命周期 变更缘由原来（React v16.0前）的生命周期在React v16推出的Fiber之后就不合适了，因为如果要开启async rendering，在render函数之前的所有函数，都有可能被执行多次。 原来（React v16.0前）的生命周期有哪些是在render前执行的呢？ componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate 如果开发者开了async rendering，而且又在以上这些render前执行的生命周期方法做AJAX请求的话，那AJAX将被无谓地多次调用。。。明显不是我们期望的结果。而且在componentWillMount里发起AJAX，不管多快得到结果也赶不上首次render，而且componentWillMount在服务器端渲染也会被调用到（当然，也许这是预期的结果），这样的IO操作放在componentDidMount里更合适。 禁止不能用比劝导开发者不要这样用的效果更好，所以除了shouldComponentUpdate，其他在render函数之前的所有函数（componentWillMount，componentWillReceiveProps，componentWillUpdate）都被getDerivedStateFromProps替代。 也就是用一个静态函数getDerivedStateFromProps来取代被deprecate的几个生命周期函数，就是强制开发者在render之前只做无副作用的操作，而且能做的操作局限在根据props和state决定新的state React v16.0刚推出的时候，是增加了一个componentDidCatch生命周期函数，这只是一个增量式修改，完全不影响原有生命周期函数；但是，到了React v16.3，大改动来了，引入了两个新的生命周期函数。 新引入了两个新的生命周期函数 getDerivedStateFromProps，getSnapshotBeforeUpdate getDerivedStateFromPropsgetDerivedStateFromProps本来（React v16.3中）是只在创建和更新（由父组件引发部分），也就是不是不由父组件引发，那么getDerivedStateFromProps也不会被调用，如自身setState引发或者forceUpdate引发。 这样的话理解起来有点乱，在React v16.4中改正了这一点，让getDerivedStateFromProps无论是Mounting还是Updating，也无论是因为什么引起的Updating，全部都会被调用，具体可看React v16.4 的生命周期图。 React v16.4后的getDerivedStateFromProps static getDerivedStateFromProps(props, state) 在组件创建时和更新时的render方法之前调用，它应该返回一个对象来更新状态，或者返回null来不更新任何内容。 getSnapshotBeforeUpdategetSnapshotBeforeUpdate() 被调用于render之后，可以读取但无法使用DOM的时候。它使您的组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。 官网给的例子： 12345678910111213141516171819202122232425262728293031323334class ScrollingList extends React.Component { constructor(props) { super(props); this.listRef = React.createRef(); } getSnapshotBeforeUpdate(prevProps, prevState) { //我们是否要添加新的 items 到列表? // 捕捉滚动位置，以便我们可以稍后调整滚动. if (prevProps.list.length &lt; this.props.list.length) { const list = this.listRef.current; return list.scrollHeight - list.scrollTop; } return null; } componentDidUpdate(prevProps, prevState, snapshot) { //如果我们有snapshot值, 我们已经添加了 新的items. // 调整滚动以至于这些新的items 不会将旧items推出视图。 // (这边的snapshot是 getSnapshotBeforeUpdate方法的返回值) if (snapshot !== null) { const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; } } render() { return ( &lt;div ref={this.listRef}&gt;{/* ...contents... */}&lt;/div&gt; ); }} 参考鸣谢 程墨Morgan老师的React v16.3之后的组件生命周期函数","link":"/2019/04/18/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"一些感触","text":"从毕业到现在，工作也快1年半了，这一年来变化真是很大。当初大四最后一学期的补Java基础，看框架视频，做了半本书的笔记，现在也不知道在哪了；从找实习，找工作时的迷茫到现在的可以独立开发一些小项目，从无到有，更让自己觉得要学的东西太多，也在后悔大学没有好好努力，没有早点认识到方向的重要性。 去年的3月份，带着妹妹和好友Y去长沙旅游，Y君从山东飞到长沙，我们坐高铁到火车站，当时天色已晚，我们从火车站坐的士去机场接机。司机师傅是当地人，车程大约一个小时左右，我用我蹩脚的武汉话和司机师傅拉起家常。当时说的琐事已经记不清了，只记得他说:人在年轻的时候最容易迷茫，不知道自己到底要做什么，好多人都是在迷迷茫茫中，青春就过去了。做着自己不喜欢的事，到头来竹篮打水。最好做好计划，但是必须要长远，五年也行，十年也行。可以做一年的的计划，但是这些事情都必须很具体。下车时，他聊得投机，看我们也是学生，要少收一点，我还是按原价给了他。之后妹妹说起在的士上的事情，只说我在连连点头，满口嗯嗯。我是很赞同他说的话，除开我是一个很没有安全感的人以外，我这个人对未来也没有太多的想法，回想从前，每个时期都会觉得之前的日子完全是浪费。学校的生涯，初中、高中、大学，到现在，每一步都是随性走过来的。大多数时间竟然都是在焦虑中度过，如果懂的再多一点，面对事情的时候就会更有把握一点。可惜，时间只能一直向前走。 这世界上唯一不变的事情就是永远在变。事情是如此，人与人也是如此，期望没有经过付出的回报是毫无意义的。人与人之间的关系总是很微妙，好友和亲人有时可以混为一谈，更多的时候，家人，是唯一不向你索取却一直给予的人。人总是能从别人的身上学到东西。见人说人话，见鬼说鬼话；这是上辈语重心长说出来的，虽然当时他已经喝醉了，不过半辈子人生和社会经验融成的这句话，确实也让我感觉到一点其中的深意。我不喜欢一直抓着一个东西不放，如果一直耿耿于怀，心理生理上都会感觉憋屈，那些走过的坑，踩过的泥潭，都值得感谢，感谢让我体会到了这种感觉，不会再来一次的感觉。去年给自己定了一个备忘录，时间是一年后，内容是: 你有一番作为了吗？现在看来，和自己的想法差距甚大，反观现在，依然是随性，不过焦虑少了一些，改变是有的，不过前路漫漫。计划还是没有完成，一年前我会想到现在是怎么样吗？我现在又能想到一年后会是怎样吗？五年呢，十年呢？没有想法，只能从具体的事情开始做起。短期计划尚不能保证完全如意，何况长远，只能慢慢靠近。 希望一直开心下去，每个月读一本工具书，一本著作；坚持学英语，主要是记单词；坚持锻炼身体，可以跑步，可以散步，也可以仰卧起坐，俯卧撑，什么都行，但是要坚持；把想学的技术栈都弄懂，这样可以少问一点，少迷茫一点，懂得越多，越要精通一门或多门，可以学感兴趣的，爬虫、大数据；算法和数据结构是很重要的东西，设计模式，存储过程等等；爱好，还有什么呢，口琴很久没有碰过了，慢慢捡起来吧；自制力是现在最欠缺的东西，不过好像渐渐开始变好了，是因为对别的事情没有兴趣了？不知道是好事还是坏事。希望可以一直做自己喜欢的事情，希望变成更好的人，希望未来的事情都会变得简单，希望可以有属于自己的一块地方，希望。","link":"/2019/04/14/%E4%B8%80%E4%BA%9B%E6%84%9F%E8%A7%A6/"},{"title":"中级脚本算法","text":"中级脚本算法1. 区间求值算法挑战我们会传递给你一个包含两个数字的数组。返回这两个数字和它们之间所有数字的和。 最小的数字并非总在最前面。 123456789101112function sumAll(arr) { var num1 = arr[0]; var num2 = arr[1]; if(num1&gt;num2){ snum = num1-num2; }else { snum = num2-num1; } return (num1+num2)*(snum+1)/2}sumAll([1, 4]); 123456789101112function sumAll(arr) {var min = Math.min(arr[0],arr[1]);var max = Math.max(arr[0],arr[1]);var newArr = [];for(var i=0;i&lt;=max-min;i++){newArr[i] = min+i;}return newArr.reduce(function(a,b){return a+b;}); }sumAll([1, 4]);","link":"/2019/02/25/%E4%B8%AD%E7%BA%A7%E8%84%9A%E6%9C%AC%E7%AE%97%E6%B3%95/"},{"title":"关于junit发现的jar包问题","text":"关于junit发现的jar包问题首先需要引入junit的jar包 1import org.junit.Test; 然后在需要进行单元测试的方法上加上注解 @Test 但是在Run junit的时候，却报了以下异常 123456789101112131415161718192021222324252627282930313233343536373839java.lang.NoClassDefFoundError: org/hamcrest/SelfDescribing at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:621) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:124) at java.net.URLClassLoader.defineClass(URLClassLoader.java:260) at java.net.URLClassLoader.access$000(URLClassLoader.java:56) at java.net.URLClassLoader$1.run(URLClassLoader.java:195) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:188) at java.lang.ClassLoader.loadClass(ClassLoader.java:307) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301) at java.lang.ClassLoader.loadClass(ClassLoader.java:252) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:320) at java.lang.Class.getDeclaredConstructors0(Native Method) at java.lang.Class.privateGetDeclaredConstructors(Class.java:2389) at java.lang.Class.getConstructor0(Class.java:2699) at java.lang.Class.getConstructor(Class.java:1657) at org.junit.internal.builders.AnnotatedBuilder.buildRunner(AnnotatedBuilder.java:29) at org.junit.internal.builders.AnnotatedBuilder.runnerForClass(AnnotatedBuilder.java:21) at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:59) at org.junit.internal.builders.AllDefaultPossibilitiesBuilder.runnerForClass(AllDefaultPossibilitiesBuilder.java:26) at org.junit.runners.model.RunnerBuilder.safeRunnerForClass(RunnerBuilder.java:59) at org.junit.internal.requests.ClassRequest.getRunner(ClassRequest.java:26) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.&lt;init&gt;(JUnit4TestReference.java:33) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestClassReference.&lt;init&gt;(JUnit4TestClassReference.java:25) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestLoader.createTest(JUnit4TestLoader.java:48) at org.eclipse.jdt.internal.junit4.runner.JUnit4TestLoader.loadTests(JUnit4TestLoader.java:38) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:452) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:683) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:390) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:197)Caused by: java.lang.ClassNotFoundException: org.hamcrest.SelfDescribing at java.net.URLClassLoader$1.run(URLClassLoader.java:200) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:188) at java.lang.ClassLoader.loadClass(ClassLoader.java:307) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:301) at java.lang.ClassLoader.loadClass(ClassLoader.java:252) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:320) 搜索得知：是因为缺少了jar包 junit.jar: Includes the Hamcrest classes. The simple all-in-one solution to get started quickly.Starting with version 4.11, Hamcrest is no longer included in this jar. junit-dep.jar: Only includes the JUnit classes but not Hamcrest. Lets you use a different Hamcrest version. 解决方案使用时导入包的方案： junit.jar + hamcrest-core.jar + hamcrest-library.jar 或者是：junit-dep.ajr+hancrest-all.jar 原文：https://blog.csdn.net/castle07/article/details/8553704 jar包下载地址：http://www.java2s.com/Code/Jar/h/Catalogh.htm","link":"/2019/02/13/%E5%85%B3%E4%BA%8Ejunit%E5%8F%91%E7%8E%B0%E7%9A%84jar%E5%8C%85%E9%97%AE%E9%A2%98/"},{"title":"初步了解Normalize.css","text":"初步了解Normalize.css 译文链接原文链接 Normalize.css 只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。Normalize.css现在已经被用于Twitter Bootstrap、HTML5 Boilerplate、GOV.UK、Rdio、CSS Tricks 以及许许多多其他框架、工具和网站上。 Normalize.css 项目地址 Normalize.css 在GitHub上的源码 综述Normalize.css是一种CSS reset的替代方案。经过@necolas和@jon_neal花了几百个小时来努力研究不同浏览器的默认样式的差异，这个项目终于变成了现在这样。 我们创造normalize.css有下面这几个目的： 保护有用的浏览器默认样式而不是完全去掉它们 一般化的样式：为大部分HTML元素提供 修复浏览器自身的bug并保证各浏览器的一致性 优化CSS可用性：用一些小技巧 解释代码：用注释和详细的文档来 Normalize.css支持包括手机浏览器在内的超多浏览器，同时对HTML5元素、排版、列表、嵌入的内容、表单和表格都进行了一般化。尽管这个项目基于一般化的原则，但我们还是在合适的地方使用了更实用的默认值。 Normalize vs Reset知道Normalize.css和传统Reset的区别是非常有价值的。 1. Normalize.css 保护了有价值的默认值Reset通过为几乎所有的元素施加默认样式，强行使得元素有相同的视觉效果。相比之下，Normalize.css保持了许多默认的浏览器样式。这就意味着你不用再为所有公共的排版元素重新设置样式。当一个元素在不同的浏览器中有不同的默认值时，Normalize.css会力求让这些样式保持一致并尽可能与现代标准相符合。 2. Normalize.css 修复了浏览器的bug它修复了常见的桌面端和移动端浏览器的bug。这往往超出了Reset所能做到的范畴。关于这一点，Normalize.css修复的问题包含了HTML5元素的显示设置、预格式化文字的font-size问题、在IE9中SVG的溢出、许多出现在各浏览器和操作系统中的与表单相关的bug。 可以看以下这个例子，看看对于HTML5中新出现的input类型search，Normalize.css是如何保证跨浏览器的一致性的。 1234567891011121314151617181920/** * 1. Addresses appearance set to searchfield in S5, Chrome * 2. Addresses box-sizing set to border-box in S5, Chrome (include -moz to future-proof) */input[type=&quot;search&quot;] { -webkit-appearance: textfield; /* 1 */ -moz-box-sizing: content-box; -webkit-box-sizing: content-box; /* 2 */ box-sizing: content-box;}/** * Removes inner padding and search cancel button in S5, Chrome on OS X */input[type=&quot;search&quot;]::-webkit-search-decoration,input[type=&quot;search&quot;]::-webkit-search-cancel-button { -webkit-appearance: none;} 3. Normalize.css 不会让你的调试工具变的杂乱使用Reset最让人困扰的地方莫过于在浏览器调试工具中大段大段的继承链，如下图所示。在Normalize.css中就不会有这样的问题，因为在我们的准则中对多选择器的使用时非常谨慎的，我们仅会有目的地对目标元素设置样式。 4. Normalize.css 是模块化的这个项目已经被拆分为多个相关却又独立的部分，这使得你能够很容易也很清楚地知道哪些元素被设置了特定的值。因此这能让你自己选择性地移除掉某些永远不会用到部分（比如表单的一般化）。 5. Normalize.css 拥有详细的文档Normalize.css的代码基于详细而全面的跨浏览器研究与测试。这个文件中拥有详细的代码说明并在Github Wiki中有进一步的说明。这意味着你可以找到每一行代码具体完成了什么工作、为什么要写这句代码、浏览器之间的差异，并且你可以更容易地进行自己的测试。 这个项目的目标是帮助人们了解浏览器默认是如何渲染元素的，同时也让人们很容易地明白如何改进浏览器渲染。 如何使用 normalize.css首先，安装或从Github下载Normalize.css，接下来有两种主要途径去使用它。 策略一：将normalize.css作为你自己项目的基础CSS，自定义样式值以满足设计师的需求。 策略二：引入normalize.css源码并在此基础上构建，在必要的时候用你自己写的CSS覆盖默认值。 结语无论从适用范畴还是实施上，Normalize.css与Reset都有极大的不同。尝试一下这两种方法并看看到底哪种更适合你的开发偏好是非常值得的。这个项目在Github上以开源的形式开发。任何人都能够提交问题报告或者提交补丁。整个项目发展的过程对所有人都是可见的，而每一次改动的原因也都写在commit信息中，这些都是有迹可循的。 相关阅读关于更多默认UA样式的详细信息： WHATWG suggestions for rendering HTML documents Internet Explorer User Agent Style Sheets CSS2.1 User Agent Style Sheet Defaults","link":"/2020/04/08/%E5%88%9D%E6%AD%A5%E4%BA%86%E8%A7%A3Normalize-css/"},{"title":"初级脚本算法-2","text":"初级脚本算法-25. 设置首字母大写算法挑战返回一个字符串,确保字符串的每个单词首字母都大写，其余部分小写。 像’the’和’of’这样的连接符同理。 12345678910function titleCase(str) { var arr = str.toLowerCase().split(&quot; &quot;); for(i=0;i&lt;arr.length;i++){ arr[i] = arr[i][0].toUpperCase() + arr[i].substring(1,arr[i].length); } return arr.join(&quot; &quot;);}titleCase(&quot;I'm a little tea pot&quot;); 6. 寻找数组中的最大值算法挑战 在右边的大数组中包含了4个小数组，请分别找到每个小数组中的最大值，然后把它们串联起来，形成一个新的数组。 提示：你可以用for循环来迭代数组，并通过arr[i]的方式来访问数组的每个元素。 123456789101112131415161718192021function largestOfFour(arr) {// You can do this!var maxArr = [];for(var i = 0;i &lt; arr.length;i++){ for(var j = 0;j &lt; arr[i].length;j++){ if(j === 0){ maxArr[i] = arr[i][j]; }else{ maxArr[i] = arr[i][j] &gt; maxArr[i]?arr[i][j]:maxArr[i]; } }}return maxArr;}largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); 7.确认末尾字符算法挑战检查一个字符串(str)是否以指定的字符串(target)结尾. 如果是，返回true;如果不是，返回false。 这个挑战可以通过在ES2015中引入的.endsWith()方法来解决。但是出于这个挑战的目的，我们希望您使用JavaScript子串方法之一。 12345678910function confirmEnding(str, target) {// &quot;Never give up and good luck will find you.&quot;// -- Falcorvar substr = str.substr(-target.length);// return str.endsWith(target);return target === substr;}confirmEnding(&quot;Bastian&quot;, &quot;n&quot;); 8.重复操作算法挑战循环拼接一个指定的字符串 num次，如果num是一个负数,则返回一个空字符串。 123456789101112function repeat(str, num) {// repeat after mevar substr=''if(num=&gt;0){ for(i=0;i&lt;num; i++){ substr = substr+str; }}return substr;}repeat(&quot;abc&quot;, 3); 9.字符串截取算法挑战如果字符串的长度比给定的参数num长，则把多余的部分用…来表示。 切记，插入到字符串尾部的三个点号也会计入字符串的长度。 然而，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。 12345678910111213141516function truncate(str, num) { var newStr=&quot;&quot;; if(str.length&gt;num){ if(num&lt;=3){ newStr = str.slice(0,num)+&quot;...&quot;; }else{ newStr = str.slice(0,num-3)+&quot;...&quot;; } }else{ newStr=str; } return newStr;} truncate(&quot;A-tisket a-tasket A green and yellow basket&quot;, 11);","link":"/2019/02/20/%E5%88%9D%E7%BA%A7%E8%84%9A%E6%9C%AC%E7%AE%97%E6%B3%95-2/"},{"title":"初级脚本算法-3","text":"初级脚本算法-310. 数组分割算法挑战编写一个函数,把一个数组arr按照指定的数组大小size分割成若干个数组块。 1234567891011function chunk(arr, size) {// Break it up. var newArr = []; for(var i = 0;i &lt; arr.length;i = i + size){ newArr.push(arr.slice(i,i+size)); } return newArr;}chunk([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;], 2); 11. 数组截断算法挑战 返回一个数组被截断n个元素后还剩余的元素，从索引0开始截断。 123456789 function slasher(arr, howMany) {// it doesn't always pay to be first if(arr.length&lt;=howMany){ return []; }else{ return arr.slice(howMany) }}slasher([1, 2, 3], 2); 12. 数组查询算法挑战 如果数组第一个字符串元素包含了第二个字符串元素的所有字符，则函数返回true。 举例，[&quot;hello&quot;, &quot;Hello&quot;]应该返回true，因为在忽略大小写的情况下，第二个字符串的所有字符都可以在第一个字符串找到。 [&quot;hello&quot;, &quot;hey&quot;]应该返回false，因为字符串”hello”并不包含字符”y”。 [&quot;Alien&quot;, &quot;line&quot;]应该返回true，因为”line”中所有字符都可以在”Alien”找到。 123456789101112131415function mutation(arr) {str1 = arr[0].toLowerCase();str2 = arr[1].toLowerCase();for (var i = 0; i &lt; str2.length; i++) { if (str1.indexOf(str2[i]) &lt; 0) { return false; }}return true;}mutation([&quot;hello&quot;, &quot;hey&quot;]); 获取字符串的某个字符有两种方法。 第一种是使用 charAt 方法： return &apos;cat&apos;.charAt(1); // returns &quot;a&quot; 另一种 (在ECMAScript 5中有所介绍) 是把字符串当作一个类似数组的对象，其中的每个字符对应一个数值索引： return &apos;cat&apos;[1]; // returns &quot;a&quot; 使用括号访问字符串不可以对其进行删除或添加，因为字符串对应未知的属性并不是可读或配置的。 13.删除数组中特定值算法挑战删除数组中的所有的假值。 在JavaScript中，假值有false、null、0、&quot;&quot;、undefined 和 NaN。 123456789function bouncer(arr) {// Don't show a false ID to this bouncer.const result = arr.filter(item =&gt; !(!item || item === &quot;&quot;));return result;}bouncer([7, &quot;ate&quot;, &quot;&quot;, false, 9]); 14.去除数组中任意多个值算法挑战实现一个 destroyer 函数，第一个参数是初始数组，后跟一个或多个参数。从初始数组中删除与这些参数具有相同值的所有元素。 1234567891011121314function destroyer(arr) { //arguments是保存当前函数所有的参数的类数组对象 var argArr = arguments; //遍历参数数组，与初始数组的每个元素进行比较，返回初始数组中不同的元素 for(var i = 1; i &lt; argArr.length; i++){ arr = arr.filter(function(val){ return argArr[i] !== val; }); } return arr;}destroyer([1, 2, 3, 5, 1, 2, 3], 2, 3); 15.数组排序并插入值算法挑战先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。 举例：where([1,2,3,4], 1.5) 应该返回1。因为1.5插入到数组[1,2,3,4]后变成[1,1.5,2,3,4]，而1.5对应的索引值就是1。 同理，where([20,3,5], 19) 应该返回 2。因为数组会先排序为 [3,5,20]，19插入到数组[3,5,20]后变成[3,5,19,20]，而19对应的索引值就是2 1234567891011function where(arr, num) {// Find my place in this sorted array.arr.push(num); arr.sort(function(a,b){ return a-b; }); return arr.indexOf(num);} where([40, 60], 50); sort() 方法用于对数组的元素进行排序。 arrayObject.sort(sortby) sortby 可选。规定排序顺序。必须是函数。 返回值 对数组的引用。请注意，数组在原数组上进行排序，不生成副本。 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b，则返回 0。 若 a 大于 b，则返回一个大于 0 的值。 16. 位移密码算法挑战下面我们来介绍著名的凯撒密码Caesar cipher，又叫移位密码。 移位密码也就是密码中的字母会按照指定的数量来做移位。 一个常见的案例就是ROT13密码，字母会移位13个位置。由’A’ ↔ ‘N’, ‘B’ ↔’O’，以此类推。 写一个ROT13函数，实现输入加密字符串，输出解密字符串。 所有的字母都是大写，不要转化任何非字母形式的字符(例如：空格，标点符号)，遇到这些特殊字符，就跳过它们 123456789101112131415161718function rot13(str) { // LBH QVQ VG!var patt1=new RegExp(&quot;[A-Z]&quot;);var arr = str.split(&quot;&quot;);for(i=0;i&lt;arr.length;i++){ if(patt1.test(arr[i])){ var temp = arr[i].charCodeAt(); temp = temp -13; if(temp&lt;65){ temp = temp+26; } arr[i] = String.fromCharCode(temp); }}return arr.join(&quot;&quot;);}// Change the inputs below to testrot13(&quot;SERR PBQR PNZC&quot;); 123456789101112131415161718function rot13(str) { //定义一个数组，用来存放解密后的字符 var newArr = []; //遍历参数字符串 for (var i = 0; i &lt; str.length; i++) { // 非字母形式的字符，直接跳过，存入数组newArr中 if (str.charCodeAt(i) &lt; 65 || str.charCodeAt(i) &gt; 90) { newArr.push(str.charAt(i)); } else if (str.charCodeAt(i) &gt; 77) { // 后13个大写字母，减去13 newArr.push(String.fromCharCode(str.charCodeAt(i) - 13)); } else { // 前13个大写字母，加上13 newArr.push(String.fromCharCode(str.charCodeAt(i) + 13)); } } return newArr.join(&quot;&quot;);}","link":"/2019/02/25/%E5%88%9D%E7%BA%A7%E8%84%9A%E6%9C%AC%E7%AE%97%E6%B3%95-3/"},{"title":"初级脚本算法","text":"初级脚本算法1. 实战翻转字符串算法 你可以先把字符串转化成数组，再借助数组的reverse方法翻转数组顺序，然后把数组转化成字符串。 提示:你的结果必须得是一个字符串 123456function reverseString(str) { str = str.split(&quot;&quot;).reverse().join(&quot;&quot;); return str;}reverseString(&quot;hello&quot;); 1234function reverseString(str) { return str&amp;&amp;reverseString(str.slice(1)) + str[0]; }reverseString(&quot;hello&quot;) 2. 阶乘算法挑战计算所提供整数的阶乘。 如果使用字母n代表一个整数，则阶乘是所有小于或等于n的整数的乘积。 阶乘通常简写成 n!例如: 5! = 1 * 2 * 3 * 4 * 5 = 120 12345678910111213function factorialize (num) { if (num &lt; 0) { return -1; } else if (num === 0 || num === 1) { return 1; } else { for (var i = num - 1; i &gt;= 1; i--) { num *= i; } } return num;};factorialize(5); 1234567function factorialize(num){ if (num &lt;=1) { return 1; } else { return num * arguments.callee(num-1) } } 3.回文算法挑战如果给定的字符串是回文，返回true，反之，返回false。 palindrome(回文)是指一个字符串忽略标点符号、大小写和空格，正着读和反着读一模一样。 注意: 您需要删除字符串多余的标点符号和空格，然后把字符串转化成小写来验证此字符串是不是回文。 1234567function palindrome(str) { var re = /[\\W_]/g; // 或者 var re = /[^A-Za-z0-9]/g; var lowRegStr = str.toLowerCase().replace(re,''); var reverseStr = lowRegStr.split('').reverse().join(''); return reverseStr === lowRegStr; } 1234function palindrome(str) { return str.replace(/[\\W_]/g, '').toLowerCase() === str.replace(/[\\W_]/g, '').toLowerCase().split('').reverse().join(''); } 参考原帖地址 4.寻找最长的单词算法挑战返回提供的句子中最长的单词的长度。 返回值应该是一个数字。 123456789101112function findLongestWord(str) {var arr = str.split(&quot; &quot;);var maxLength = 0;for(var i =0;i&lt;arr.length;i++){ if(arr[i].length &gt; maxLength){ maxLength = arr[i].length; }}return maxLength;}findLongestWord(&quot;The quick brown fox jumped over the lazy dog&quot;);","link":"/2019/02/19/%E5%88%9D%E7%BA%A7%E8%84%9A%E6%9C%AC%E7%AE%97%E6%B3%95/"},{"title":"利用momentJS获取当天凌晨的时间戳","text":"12345let now = moment().format('YYYY-MM-DD');let zero = moment(now).format('YYYY-MM-DD HH:mm:ss');let today = moment(zero).toDate().getTime();let yesterday = moment(today).subtract(1, 'days').format('x'); 在线实例","link":"/2019/12/09/%E5%88%A9%E7%94%A8momentJS%E8%8E%B7%E5%8F%96%E5%BD%93%E5%A4%A9%E5%87%8C%E6%99%A8%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3/"},{"title":"在浏览器中输入url后发生了什么?","text":"参考资料：https://www.jianshu.com/p/c1dfc6caa520推荐阅读：https://www.zhihu.com/question/34873227深度阅读：https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/https://kb.cnblogs.com/page/129756/https://coolshell.cn/articles/9666.htmlhttps://www.cnblogs.com/tisikcci/p/5866753.htmlhttps://blog.csdn.net/xifeijian/article/details/10813339非常详细： http://blog.jobbole.com/84870/ what happend？上脑图！ 解析URL关于URL：URL（Universal Resource Locator）：统一资源定位符。俗称网页地址或者网址。URL用来表示某个资源的地址。（通过俗称就能看出来）URL主要由以下几个部分组成： 传输协议 服务器 域名 端口 虚拟目录 文件名 锚 参数 也就是说，通常一个URL是像下面这样 连起来就是：http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name 上面的链接有几个要注意的地方：; 和/的使用，80端口默认不显示，? 到#之间跟着参数，多个参数使用&amp;连接，#后面跟着锚。 现在来讨论URL解析，当在浏览器中输入URL后，浏览器首先对拿到的URL进行识别，抽取出域名字段。 DNS解析DNS解析（域名解析），DNS实际上是一个域名和IP对应的数据库。 IP地址往都难以记住，但机器间互相只认IP地址，于是人们发明了域名，让域名与IP地址之间一一对应，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，整个过程是自动进行的。 可以在浏览器中输入IP地址浏览网站，也可以输入域名查询网站，虽然得出的内容是一样的但是调用的过程不一样，输入IP地址是直接从主机上调用内容，输入域名是通过域名解析服务器指向对应的主机的IP地址，再从主机调用网站的内容。 在进行DNS解析时，会经历以下步骤： 查询浏览器缓存（浏览器会缓存之前拿到的DNS 2-30分钟时间），如果没有找到， 检查系统缓存，检查hosts文件，这个文件保存了一些以前访问过的网站的域名和IP的数据。它就像是一个本地的数据库。如果找到就可以直接获取目标主机的IP地址了。没有找到的话，需要 检查路由器缓存，路由器有自己的DNS缓存，可能就包括了这在查询的内容；如果没有，要 查询ISP DNS 缓存：ISP服务商DNS缓存（本地服务器缓存）那里可能有相关的内容，如果还不行的话，需要， 递归查询：从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索对应目标域名的IP。 通过以上的查找，就可以获取到域名对应的IP了。接下来就是向该IP地址定位的HTTP服务器发起TCP连接。 浏览器与网站建立TCP连接（三次握手） 参考 请求和传输数据发起HTTP请求，请求方法： GET: 获取资源 POST: 传输实体主体 HEAD: 获取报文首部 PUT: 传输文件 DELETE: 删除文件 OPTIONS: 询问支持的方法 TRACE: 追踪路径 请求报文： 接受响应结果状态码： 1**：信息性状态码 2**：成功状态码 200：OK 请求正常处理 204：No Content请求处理成功，但没有资源可返回 206：Partial Content对资源的某一部分的请求 3**：重定向状态码 301：Moved Permanently 永久重定向 302：Found 临时性重定向 304：Not Modified 缓存中读取 4**：客户端错误状态码 400：Bad Request 请求报文中存在语法错误 401：Unauthorized需要有通过Http认证的认证信息 403：Forbidden访问被拒绝 404：Not Found无法找到请求资源 5**：服务器错误状态码 500：Internal Server Error 服务器端在执行时发生错误 503：Service Unavailable 服务器处于超负载或者正在进行停机维护 请求报文： 浏览器解析Html浏览器按顺序解析html文件，构建DOM树，在解析到外部的css和js文件时，向服务器发起请求下载资源，若是下载css文件，则解析器会在下载的同时继续解析后面的html来构建DOM树，则在下载js文件和执行它时，解析器会停止对html的解析。这便出现了js阻塞问题。 预加载器：当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的html，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索HTML标签中的URL，无法检测到使用脚本添加的URL，这些资源要等脚本代码执行时才会获取。 注: 预解析并不改变Dom树，它将这个工作留给主解析过程浏览器解析css，形成CSSOM树，当DOM树构建完成后，浏览器引擎通过DOM树和CSSOM树构造出渲染树。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head元素和display值为none的元素） 值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 浏览器布局渲染 布局：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。 绘制：将计算好的每个像素点信息绘制在屏幕上 在页面显示的过程中会多次进行Reflow和Repaint操作，而Reflow的成本比Repaint的成本高得多的多。因为Repaint只是将某个部分进行重新绘制而不用改变页面的布局，如：改变了某个元素的背景颜色。而如果将元素的display属性由block改为none则需要Reflow。","link":"/2019/05/09/%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5url%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"},{"title":"数据库事务(Transaction)","text":"什么是事务？ Transaction 数据库事务(transaction)就是一组SQL语句，这组SQL语句是一个逻辑工作单元(logical unit of work). 可以认为事务就是一组不可分割的SQL语句，其结果应该作为整体永久性地修改数据库的内容，或者作为整体取消对数据库的修改。 (精通Oracle Database 12c SQL&amp;PL/SQL编程 269) 数据库事务的一个例子就是将钱从一个银行账户转到另一个银行账户中去。此时通常包含两个操作：一条UPDATE语句负责从一个银行账户的总额中减去一定的钱数，另一条UPDATE语句负责向另一个银行账户中增加相应的钱数。减少和增加这两个操作必须永久性的记录到数据库中，否则钱就会丢失。如果钱的转账有问题，就必须同时取消减少和增加 这两个操作。这个简单的例子只使用了两条UPDATE语句，然而事务可以包含多条INSERT、UPDATE、和DELETE语句。 换言之，事务可以概括为：一个最小的不可再分的工作单元；通常一个事务对应一个完整的业务(例如银行账户转账业务，该业务就是一个最小的工作单元) 一个完整的业务需要批量的DML(insert、update、delete)语句共同联合完成 事务只和DML语句有关，或者说DML语句才有事务。这个和业务逻辑有关，业务逻辑不同，DML语句的个数不同 事务的提交和回滚要永久性的记录事务中的SQL语句的结果，需要执行COMMIT语句。要取消SQL语句的结果，需要执行ROLLBACK语句，将所有行重新设置为原始状态。 事务的开始与结束事务是用来分割SQL语句的逻辑工作单元。事务既有起点，也有终点；当下列事件之一发生时，事务就开始了： 连接到数据库，并执行一条DML语句(INSERT、UPDATE、或DELETE)。注意，MERGE也是DML语句。 前一个事务结束后，又输入了另一条DML语句。 当下列事件之一发生时，事务就结束了： 执行COMMIT或ROLLBACK语句。 执行一条DDL语句，例如CREATE TABLE语句；在这种情况下，会自动执行COMMIT语句。 执行一条DCL语句，例如GRANT语句；在这种情况下会自动执行COMMIT语句。 注意： 自动的COMMIT语句被加在DDL和DCL语句前，因此即使DDL和DCL语句没有成功，也会执行COMMIT语句。 断开数据库的连接。断开连接时会执行COMMIT语句，但是当意外中止(如程序崩溃)时，会自动执行ROLLBACK语句。这适用于任何可能访问数据库的程序。例如，如果编写了一个可以访问数据库的Java程序，而这个程序崩溃了，就会自动执行ROLLBACK语句。 执行了一条DML语句，该语句却失败了；在这种情况下，会自动为这条无效的DML语句执行ROLLBACK语句。 提示 ： 不显式提交或回滚被认为是不好的编程习惯，因此确保在每个事务后面都要执行COMMIT或者ROLLBACK语句。 保存点在事务中的任何地方都可以设置保存点(savepoint)，这样可以将修改回滚到保存点处。如果有一个很大的事务，这将非常有用，因为这样如果在保存点后进行了误操作，并不需要将整个事务一直回滚到最开头。但是保存点不能肆意乱用；最好是重新调整一下事务的结构，将其转换为较小的事务。 事务与数据库底层数据在事务进行过程中，未结束之前，DML语句是不会更改底层数据，只是将历史操作记录一下，在内存中完成记录。只有在事物结束的时候，而且是成功的结束的时候，才会修改底层硬盘文件中的数据。 事务的ACID特性在前面我们将事务定义为逻辑工作单元，即一组相关的SQL语句，它们要么作为一个单位被提交，要么作为一个单位被回滚。数据库理论对事务采用了更严格的定义，说明事务有4个基本的特征，称为ACID特性。 原子性(Atomic)： 事务是原子的，这就是说事务中包含的所有SQL语句组成一个工作单元。 一致性(Consist)： 事务必须确保数据的状态保持一致，这就是说事务开始时，数据库的状态是一致的；在事务结束后，数据库的状态也必须是一致的。 隔离性(Isolated)： 多个事务可以独立运行，而不会彼此产生影响。 持久性(Durable)： 一旦事务被提交之后，数据库的变化就会被永久保存下来，即使运行数据库的软件的机器后来崩溃也是如此。 并发事务Oracle数据库软件支持多个用户同时与数据库进行交互，每个用户都可以同时运行自己的事务。这种事务就称为并发事务(concurrent transaction)。 如果用户同时运行多个事务，而这些事务都对同一个表产生影响，那么这些事务的影响都是独立的，直到执行一条COMMIT语句时才会彼此产生影响。 下面两个事务T1和T2都会访问customers表，看下面这个例子展示事务的隔离性： 1. T1和T2分别执行SELECT语句，检索customers表的所有行 2. T1执行INSERT语句，向customers表中插入数据，但此时T1并不执行COMMIT语句。 3. T2再执行一条SELECT语句，检索结果和步骤1中相同，T2没有“看到”T1在步骤2中插入的新行。 4. T1最后执行COMMIT语句，永久性的保存了插入的新行。 5. T2执行一条SELECT语句，最终看到了T1插入的新行。以上过程可以归纳如下： 直到T1提交自己对数据库所做的修改之后，T2才能看得到T1对数据库所做的修改。这是事务间隔离性的默认级别。隔离性级别可以修改 事务T1 事务T2 (1) SELECT * FROM customers; (2) SELECT * FROM customers; (3) INSERT INTO customers(xx, xx, xx) VALUES (XX, XX, XX); (4)UPDATE customers SET xx = XX WHERE customer_xx = X; (5) SELECT * FROM customers;返回的结果集中包含新插入的行和修改后的行 (6) SELECT * FROM customers;返回的结果集中不包含事务T1插入和修改后的行，而是在步骤2中检索出来的原来的行 (7) COMMIT;提交新行和所做的修改 (8)SELECT * FROM customers; 返回的结果集中包含T1在步骤3和步骤4中插入和修改的行 事务锁要实现并发事务，Oracle 数据库软件必须确保表中的数据一直有效。这可以通过锁(lock)来实现。下面这个例子：事务T1和T2都试图修改customers表中的顾客#1： T1执行一条UPDATE语句，修改顾客#1,但是T1并没有执行COMMIT语句。此时就称T1对该行“加锁”了。 T2也试图执行一条UPDATE语句，修改顾客#1，但是由于该行早已被T1加锁了，因此T2现在就不能获得该行的锁。T2的UPDATE语句必须一直等待，直到T1结束并释放该行上的锁为止。 T1执行COMMIT语句并结束，从而释放该行上的锁。 T2获得该行上的锁，并执行UPDATE语句。T2在获得该行上的锁后一直持有，直到T2结束为止。 以上过程概括为： 当一个事务已经拥有某一行上的锁时，另外一个事务不能获得该行上的锁。 注意：理解默认加锁机制的最简单方法如下：读程序(reader)不会阻碍读程序；写程序(writer)不会阻碍读程序；只有在试图对相同的行进行修改时，写程序才会阻碍写程序。 事务的隔离级别在SQL的标准中，定义了四种隔离级别。每一种级别都规定了，在一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。低级别的隔离可以执行更高级别的并发，性能好，但是会出现脏读和幻读的现象。首先，我们从三个基础的概念说起： 脏读（dirty read）：两个事务，一个事务读取到了另一个事务未提交的数据，这便是脏读。 幻读（phantom read）：两个事务，事务A与事务B，事务A在自己执行的过程中，执行了两次相同查询，第一次查询事务B未提交，第二次查询事务B已提交，从而造成两次查询结果不一样，这个其实被称为不可重复读；如果事务B是一个会影响查询结果的insert操作，则好像新多出来的行像幻觉一样，因此被称为幻读。其他事务的提交会影响在同一个事务中的重复查询结果。 不可重复读（nonrepeatable read）：两个事务，事务T1读取一行，紧接着事务T2修改了T1刚才读取的那一行的内容。然后T1又读取了这一行，发现它与刚才读取的结果不同了。这种现象称为“不可重复读”，因为T1原来读取的那一行已经发生了变化。 下面简单描述一下SQL中定义的四种标准隔离级别： READ UNCOMMITTED (未提交读) ： 隔离级别：0. 事物A和事物B，事物A未提交的数据，事物B可以读取到 可以读取未提交的记录。 会出现脏读。 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别 READ COMMITTED (提交读) ： 隔离级别：1. 事物A和事物B，事物A提交的数据，事物B才能读取到 事务中只能看到已提交的修改。 不可重复读，会出现幻读。（在InnoDB中，会加行所，但是不会加间隙锁） 该隔离级别是大多数数据库系统(如Oracle)的默认隔离级别，但是MySQL的则是RR。 REPEATABLE READ (可重复读) ： 隔离级别：2. 事务A和事务B，事务A提交之后的数据，事务B读取不到 事务B是可重复读取数据 换句话说，对方提交之后的数据，我还是读取不到 MySQL默认级别 在InnoDB中是这样的：RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，因此不存在幻读现象。但是标准的RR只能保证在同一事务中多次读取同样记录的结果是一致的，而无法解决幻读问题。 InnoDB的幻读解决是依靠MVCC的实现机制做到的。 SERIALIZABLE （可串行化）： 隔离级别：3. 事务A和事务B，事务A在操作数据库时，事务B只能排队等待 这种隔离级别很少使用，吞吐量太低，用户体验差 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发 该隔离级别会在读取的每一行数据上都加上锁，退化为基于锁的并发控制，即LBCC。 需要注意的是，MVCC只在RC和RR两个隔离级别下工作，其他两个隔离级别都和MVCC不兼容。 设置事务隔离级别方式一 可以在my.ini文件中使用transaction-isolation选项来设置服务器的缺省事务隔离级别。 该选项值可以是 – READ-UNCOMMITTED – READ-COMMITTED – REPEATABLE-READ – SERIALIZABLE • 例如： [mysqld] transaction-isolation = READ-COMMITTED 方式二 通过命令动态设置隔离级别 隔离级别也可以在运行的服务器中动态设置，应使用SET TRANSACTION ISOLATION LEVEL语句。 其语法模式为：SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL &lt;isolation-level&gt; 其中的&lt;isolation-level&gt;可以是： – READ UNCOMMITTED – READ COMMITTED – REPEATABLE READ – SERIALIZABLE • 例如： SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; 隔离级别的作用范围• 事务隔离级别的作用范围分为两种： – 全局级：对所有的会话有效 – 会话级：只对当前的会话有效 • 例如，设置会话级隔离级别为READ COMMITTED ： mysql&gt; SET TRANSACTION ISOLATION LEVEL READ COMMITTED； 或： mysql&gt; SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED； • 设置全局级隔离级别为READ COMMITTED ： mysql&gt; SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED；查看隔离级别select @@global.tx_isolation, @@tx_isolation 和 show variables like &apos;%isolation%&apos; 关于事务隔离级别，锁，以及并发控制与加锁分析，可参考的技术博客 事务隔离级别 并发控制与加锁分析 MySQL 加锁处理分析 引用的技术博客 MySQL——事务(Transaction)详解","link":"/2019/04/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1(Transaction)/"},{"title":"有关JS的数组方法","text":"每多学一点知识，就少写一行代码 length - 长度属性每个Array都有一个length属性，稠密数组,length属性代表数组中元素的个数；稀疏数组，length属性大于元素的个数 1234let arr = ['a','b','c'];console.log(arr.length); //3arr.length = 2;console.log(arr.length); // ['a','b'] Array.isArray - 数组类型1console.log(Array.isArray([1,2])); Array.of - 创建数组从可变数量的参数创建数组，不管参数的数量或者类型如何 1console.log(Array.of(1,2,3)); //[1,2,3] Array.from - 创建数组用类数组或可迭代对象创建新数组 12console.log(Array.from('abcd')); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]console.log(Array.from([1,2,3],x=&gt;x+1)); //[2, 3, 4] 查找元素find - 按函数查找Array.prototype.find()找到第一个满足检测条件的元素，并返回该元素，反之返回undefined. 12let arr = [1,2,3,4,5];console.log(arr.find(x =&gt; x&gt;3)); //4 findIndex - 按函数查找Array.prototype.findIndex() 找到第一个满足检测条件的元素，并返回该元素索引，反之返回-1. 12let arr = [1,2,3,6,7];console.log(arr.findIndex(x =&gt; x&gt;3)); //3 indexOf-按元素值查找Array.prototype.indexOf() 查找元素并返回元素索引值，找不到返回-1 1234let arr= [1, 2, 3, 4];console.log(arr.indexOf(3)); // 输出 2console.log(arr.indexOf(6)); // 输出 -1console.log(arr.indexOf(2, 2)); // 输出 -1 第二个参数表示查找的起始位置。 lastIndexOf-按元素值查找Array.prototype.lastIndexOf() 从后向前查找元素并返回元素索引值，找不到返回 -1。 123var arr = ['a', 'b', 'c', 'd'];console.log(arr.lastIndexOf('b')); // 输出 1console.log(arr.lastIndexOf('e')); // 输出 -1 添加元素push - 尾部添加Array.prototype.push() 在尾部添加一个或多个元素，返回数组的新长度。 123var array1= ['a', 'b', 'c'];console.log(array1.push('d')); // 输出 4console.log(array1); // 输出 [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ] unshift-头部添加Array.prototype.unshift() 在头部添加一个或多个元素，并返回数组的新长度。 12345var array1 = [ 4, 5, 6 ];console.log(array1.unshift(3)); // 输出 4console.log(array1); // 输出 [ 3, 4, 5, 6 ]console.log(array1.unshift(1, 2)); // 输出 6console.log(array1); // 输出 [ 1, 2, 3, 4, 5, 6 ] 删除元素pop-尾部删除Array.prototype.pop() 从尾部删除一个元素，并返回该元素。 1234var array1= ['a', 'b', 'c', 'd'];console.log(array1.pop()); // 输出 dconsole.log(array1); // 输出 [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ] shift-头部删除Array.prototype.shift() 从头部删除一个元素，并返回该元素。 1234var array1 = [1, 2, 3];console.log(array1.shift()); // 输出 1console.log(array1); // 输出 [ 2, 3 ] 替换元素splice-添加替换删除Array.prototype.splice() 添加、替换、删除元素。会改变原数组。 123456789var array1 = [ 'a', 'c', 'd' ];array1.splice( 1, 0, 'b');console.log(array1); // 输出 [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]array1.splice(1,1);console.log(array1); // 输出 [ &quot;a&quot;, &quot;c&quot;, &quot;d&quot; ]array1.splice(1,1,'bb','cc');console.log(array1); // 输出 [ &quot;a&quot;, &quot;bb&quot;, &quot;cc&quot;, &quot;d&quot; ]array.splice(start[, deleteCount[, item1[, item2[, ...]]]]) 参数 start：表示替换的位置 参数 deleteCount ：表示删除元素的数量 参数 item1… ： 表示添加的元素 顺序相关sort-排序Array.prototype.sort() 数组排序，改变原数组。 1234var array1 = [ 4, 3, 10, 2 ];console.log(array1.sort()); // 输出 [ 10, 2, 3, 4 ]console.log(array1.sort((x1, x2) =&gt; x1 - x2)); // 输出 [ 2, 3, 4, 10] reverse-反序Array.prototype.reverse() 倒置数组，并返回新数组。会改变原数组。 123456var sourceArray= [ 'a', 'b', 'c' ];var reverseArray = sourceArray.reverse();console.log(reverseArray); // 输出 [ &quot;c&quot;, &quot;b&quot;, &quot;a&quot; ]console.log(sourceArray == reverseArray); // 输出 true 遍历迭代keys-键迭代器Array.prototype.keys() 数组的键迭代器。 12345var array1 = ['a', 'b', 'c'];for (let key of array1.keys()) { console.log(key); // 输出 0, 1, 2} values-值迭代器Array.prototype.values() 数组的值迭代器。 123456const array1 = ['a', 'b', 'c'];const iterator = array1.values();for (const value of iterator) { console.log(value); // 输出 a b c} entries-键/值对迭代器Array.prototype.entries() 数组的键/值对迭代器。 12345var array1 = ['a', 'b', 'c'];var iterator1 = array1.entries();console.log(iterator1.next().value); // 输出 Array [0, &quot;a&quot;]console.log(iterator1.next().value); // 输出 Array [ 1, &quot;b&quot; ] forEach-遍历Array.prototype.forEach() 遍历数组中的元素，并执行回调函数。 123456var arr = [1, 2, 3, 4];arr.forEach(function (x) { console.log(x + 1); // 输出 2 3 4 5}); 检测includes-值包含检测Array.prototype.includes() 值包含检测，如包含返回 true，不包含返回false。 1234var array1 = [1, 2, 3];console.log(array1.includes(2)); // 输出 trueconsole.log(array1.includes(4)); // 输出 false some-函数包含检测Array.prototype.some() 检测数组中是否有元素可以通过检测函数验证。 12345var array1 = [ 1, 2, 3, 4 ];console.log(array1.some(x =&gt; x &gt;3)); // 输出 trueconsole.log(array1.some(x =&gt; x &gt; 5)); // 输出 false every-函数完全检测Array.prototype.every() 检测数组中是否所有元素都可以通过检测函数验证。 12345var array1 = [ 1, 2, 3, 4, 5 ];console.log(array1.every(x =&gt; x &lt; 8)); //输出 trueconsole.log(array1.every(x =&gt; x &lt; 4)); //输出 false 合并join-合并成字符串Array.prototype.join() 合并数组中所有元素成为字符串并返回。 1234var array1= [ 'a', 'b', 'c' ];console.log(array1.join()); // 输出 a,b,cconsole.log(array1.join(&quot;-&quot;)); // 输出 a-b-c concat-合并成数组Array.prototype.concat() 合并两个或多个数组，返回一个全新数组，原数组不变。 12345var array1 = [ 'a', 'b' ];var array2 = [ 'c', 'd' ];console.log(array1.concat(array2)); // 输出 [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ] 累计reduce-左侧累计Array.prototype.reduce() 从左至右按 reducer 函数组合元素值，并返回累计器终值。 1234567const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer)); // 输出 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5)); // 输出 15，其中5是累计器初始值。 reduceRight-右侧累计Array.prototype.reduceRight() 从右至左按 reducer 函数组合元素值，并返回累计器终值。 123456const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator.concat(currentValue);console.log(array1.reduceRight(reducer)); // 输出 [ 4, 3, 2, 1 ]console.log(array1.reduceRight(reducer, 5)); // 输出 [ 5, 4, 3, 2, 1 ] copyWithin-内部复制Array.prototype.copyWithin() 数组内部复制，不改变原数组长度。 12345var array1 = ['a', 'b', 'c', 'd', 'e','f'];console.log(array1.copyWithin(0, 3, 5)); // 输出 [ &quot;d&quot;, &quot;e&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; ]console.log(array1.copyWithin(1, 3)); // 输出 [ &quot;d&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;e&quot;, &quot;f&quot; ]arr.copyWithin(target[, start[, end]]) 参数target : 表示要复制到的索引位置，如为负值则从后向前计数。 参数start : 表示要复制序列的起始索引位置，如为负值则从后向前计数。如省略该值，则从索引0开始。 参数end : 表示要复制序列的结束位置，如为负值则从后向前计数。如省略该值，则复制到结尾位置。 fill-填充函数Array.prototype.fill() 用固定值填充起始索引到终止索引区间内的全部元素值，不包括终止索引。 12345var array1 = [1, 2, 3, 4];console.log(array1.fill(9, 2, 4)); // 输出 [ 1, 2, 9, 9 ]console.log(array1.fill(8, 1)); // 输出 [ 1, 8, 8, 8 ]console.log(array1.fill(7)); // 输出 [ 7, 7, 7, 7 ] filter-过滤函数Array.prototype.filter() 生成由通过检测函数验证元素组成的新数组并返回。 123var arr = [ 9 , 8 , 7 , 6];console.log(arr.filter(x =&gt; x &gt;7)); //输出 [ 9, 8 ] flat-数组扁平化Array.prototype.flat() 按指定深度递归遍历数组，并返回包含所有遍历到的元素组成的新数组。不改变原数组。 12345678var arr1 = [ 1, 2, [ 3, 4 ] ];console.log(arr1.flat()); // 输出 [ 1, 2, 3, 4 ]var arr2 = [ 1, 2, [3, 4, [ 5, 6 ] ] ];console.log(arr2.flat()); // 输出 [ 1, 2, 3, 4, [ 5, 6 ] ]var arr3 = [1, 2, [ 3, 4, [ 5, 6 ] ] ];console.log(arr3.flat(2)); // 输出 [ 1, 2, 3, 4, 5, 6 ] map-映射Array.prototype.map() 创建一个新数组，该数组中的元素由原数组元素调用map函数产生。 1234var array1 = [1, 2, 3, 4];console.log(array1.map(x =&gt; x * 2)); // 输出 [ 2, 4, 6, 8 ] slice-截取数组Array.prototype.slice() 按参数begin 和 end 截取数组，不改变原数组。 1234var array1 = [ 1, 2, 3, 4, 5];console.log(array1.slice( 2, 4 )); //输出 [ 3, 4 ]console.log(array1); //输出 [ 1, 2, 3, 4, 5 ]","link":"/2019/05/06/%E6%9C%89%E5%85%B3JS%E7%9A%84%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"title":"浅拷贝与深拷贝","text":"引用： http://jartto.wang/2016/03/19/js-deep-copy/ javascript之浅拷贝和深拷贝 什么是浅拷贝？js中的赋值都为引用传递，这也就是说，在把一个对象赋值给一个变量（对象）,那么这个变量（对象）所指向的仍就是原来对象的地址，引用就是浅拷贝。 看概念我们可能不太容易理解，下面拿一个简单的栗子来说说吧：示例： 123456789var obj1={name:'jartto'};var obj2={};//复制obj1， 给obj2赋值obj2=obj1;console.log(obj2.name);//jartto//更改obj2.nameobj2.name='somebody';console.log(obj2.name);//somebodyconsole.log(obj1.name);//somebody 例子中可以看出，obj2更改了，obj1也被更改了。这说明name仍然存在公共的引用对象，我们的拷贝并不彻底，冒然的使用很有可能带来大的灾难。这时候深拷贝就该上场了，我们接着往下走。 什么是深拷贝？深拷贝就是不仅复制对象的基本类,同时也复制原对象中的对象。就是说完全是新对象产生的，新对象所指向的不是原来对象的地址。 同上面的队形，我们还拿栗子来说事：示例： 12345678var arr1=[1,2,3];var arr2=arr1.concat();//输出arr2console.log(arr2)//更改arr2的值arr2[0]=5;console.log(arr1);//[1,2,3]console.log(arr2);//[5,2,3] arr2的值变化了，但是arr1的值并未受到影响。这也就告诉我们concat进行了一个深拷贝，arr2已经指向了新的引用地址。js中还有好多类似的例子，这里我就不一一说明啦，感兴趣你可以试试哦。 “在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误！”","link":"/2019/05/10/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"title":"浅析session,cookie,sessionStorage,localStorage的区别及应用场景","text":"原帖地址 浏览器的缓存机制提供了可以将用户数据存储在客户端上的方式，可以利用cookie,session等跟服务端进行数据交互。 一、cookie和sessioncookie和session都是用来跟踪浏览器用户身份的会话方式。 区别： 1、保持状态：cookie保存在浏览器端，session保存在服务器端 2、使用方式： （1）cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。 Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它 （2）session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。 3、存储内容：cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象) 4、存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。 5、安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。 原因如下： （1）sessionID存储在cookie中，若要攻破session首先要攻破cookie； （2）sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID； （3）第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。 （4）sessionID是加密的 （5）综上所述，攻击者必须在短时间内攻破加密的sessionID，这很难。 6、应用场景： cookie： （1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。 （2）保存上次登录的时间等信息。 （3）保存上次查看的页面 （4）浏览计数 session：Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。 （1）网上商城中的购物车 （2）保存用户登录信息 （3）将某些数据放入session中，供同一用户的不同页面使用 （4）防止用户非法登录 7、缺点：cookie： （1）大小受限 （2）用户可以操作（禁用）cookie，使功能受限 （3）安全性较低 （4）有些状态不可能保存在客户端。 （5）每次访问都要传送cookie给服务器，浪费带宽。 （6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。 session： （1）Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。 （2）依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全 （3）创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。 二、WebStorageWebStorage的目的是克服由cookie所带来的一些限制，当数据需要被严格控制在客户端时，不需要持续的将数据发回服务器。 WebStorage两个主要目标： （1）提供一种在cookie之外存储会话数据的路径。 （2）提供一种存储大量可以跨会话存在的数据的机制。 HTML5的WebStorage提供了两种API：localStorage（本地存储）和sessionStorage（会话存储）。 1、生命周期：localStorage:localStorage的生命周期是永久的，关闭页面或浏览器之后localStorage中的数据也不会消失。localStorage除非主动删除数据，否则数据永远不会消失。 sessionStorage的生命周期是在仅在当前会话下有效。sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一个页面，sessionStorage也是不一样的。 2、存储大小：localStorage和sessionStorage的存储数据大小一般都是：5MB 3、存储位置：localStorage和sessionStorage都保存在客户端，不与服务器进行交互通信。 4、存储内容类型：localStorage和sessionStorage只能存储字符串类型，对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理 5、获取方式：localStorage：window.localStorage;；sessionStorage：window.sessionStorage;。 6、应用场景：localStoragese：常用于长期登录（+判断用户是否已登录），适合长期保存在本地的数据。sessionStorage：敏感账号一次性登录； WebStorage的优点： （1）存储空间更大：cookie为4KB，而WebStorage是5MB； （2）节省网络流量：WebStorage不会传送到服务器，存储在本地的数据可以直接获取，也不会像cookie一样美词请求都会传送到服务器，所以减少了客户端和服务器端的交互，节省了网络流量； （3）对于那种只需要在用户浏览一组页面期间保存而关闭浏览器后就可以丢弃的数据，sessionStorage会非常方便； （4）快速显示：有的数据存储在WebStorage上，再加上浏览器本身的缓存。获取数据时可以从本地获取会比从服务器端获取快得多，所以速度更快； （5）安全性：WebStorage不会随着HTTP header发送到服务器端，所以安全性相对于cookie来说比较高一些，不会担心截获，但是仍然存在伪造问题； （6）WebStorage提供了一些方法，数据操作比cookie方便； setItem (key, value) —— 保存数据，以键值对的方式储存信息。 getItem (key) —— 获取数据，将键值传入，即可获取到对应的value值。 removeItem (key) —— 删除单个数据，根据键值移除对应的信息。 clear () —— 删除所有的数据 key (index) —— 获取某个索引的key","link":"/2019/02/19/%E6%B5%85%E6%9E%90session-cookie-sessionStorage-localStorage%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"},{"title":"设计模式(1)--简单工厂模式","text":"在Mybatis中比如SqlSessionFactory使用的是工厂模式，该工厂没有那么复杂的逻辑，是一个简单工厂模式。 简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 SqlSession可以认为是一个Mybatis工作的核心的接口，通过这个接口可以执行执行SQL语句、获取Mappers、管理事务。类似于连接MySQL的Connection对象。从 0 开始手写一个 Mybatis 框架，这个我推荐你看下。 可以看到，该Factory的openSession方法重载了很多个，分别支持autoCommit、Executor、Transaction等参数的输入，来构建核心的SqlSession对象。 在DefaultSqlSessionFactory的默认工厂实现里，有一个方法可以看出工厂怎么产出一个产品： 123456789101112131415161718private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) { Transaction tx = null; try { final Environment environment = configuration.getEnvironment(); final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment); tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit); final Executor executor = configuration.newExecutor(tx, execType); return new DefaultSqlSession(configuration, executor, autoCommit); } catch (Exception e) { closeTransaction(tx); // may have fetched a connection so lets call // close() throw ExceptionFactory.wrapException(&quot;Error opening session. Cause: &quot; + e, e); } finally { ErrorContext.instance().reset(); } } 这是一个openSession调用的底层方法，该方法先从configuration读取对应的环境配置，然后初始化TransactionFactory获得一个Transaction对象，然后通过Transaction获取一个Executor对象，最后通过configuration、Executor、是否autoCommit三个参数构建了SqlSession。 在这里其实也可以看到端倪，SqlSession的执行，其实是委托给对应的Executor来进行的。 而对于LogFactory，它的实现代码: 12345678910public final class LogFactory {private static Constructor&lt;? extends Log&gt; logConstructor;private LogFactory() { // disable construction}public static Log getLog(Class&lt;?&gt; aClass) { return getLog(aClass.getName());} 这里有个特别的地方，是Log变量的的类型是Constructor&lt;? extends Log&gt;，也就是说该工厂生产的不只是一个产品，而是具有Log公共接口的一系列产品，比如Log4jImpl、Slf4jImpl等很多具体的Log。","link":"/2019/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)--%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"资源整理 文章|博客|资源","text":"在查找问题和学习时找到的一些网站(待更新..) 博客 机翻的stackoverflow dang-jian的博客 廖雪峰的博客 阮一峰老师的博客 davidflanagan的博客（犀牛书） Dan Abramov 的博客 在线的markdown编辑器 markdownGuide 五分钟学算法 xiaohesong的博客(前端总结) larryzeal的博客(spring boot) CS-Notes(前端博客) jartto(前端博客) ewind(有点厉害) 认真你就输了 关注服务器和Linux 蓝色小火柴 BFDZ(资源分享) blackglory(前端博客) 熊熊咆哮(前端博客) 格物(资源整合) kamilmysliwiec.com medium社区 官方文档或翻译或资源 《CSS权威指南4th》中文翻译 Echart nestjs中文 GraphQL中文 apollographql Web | Google Developers reduxJS codesandbox lodashjs中文 lodashjs CSS 禅意花园: CSS 设计之美 ES6 入门教程 ECMAScript® 2020 Language Specification freebook 免费书籍 github 帮助文档 can i use js Info(值得推荐的js教程) hexo NexT(hexo 主题)使用文档 NexT主题 小技巧 从 NexT v5.1.x 更新 Hexo-Next7.0主题博客优化 Electron 文档 | Electron Electron学习，从零到一 - 简书 electron 部分常用功能的实现-__无字书-51CTO博客 Electron 中文文档_w3cschool How to build a React based Electron app - paachu - Medium lx-music-desktop (electron实例) 使用 Electron5.0 构建你的 React 项目 - Jartto’s blog CSS css技巧 CSS Demo展示 CSS 首页效果Demo展示 CSS 色彩效果Demo展示1 CSS 色彩效果Demo展示2 CSS 色彩效果Demo展示3 CSS 动效Demo展示 CSS 时空穿梭Demo展示 CSS 模型Demo展示1 CSS 模型Demo展示2 学习 阿里云大学开发者课堂 在线git教程 freecodecamp 在线的学习网站 程序员技能图谱 学习hooks的网站 基于VirtualBox安装Ubuntu 在线DATABASE教程 freely previewing The Design of Web APIs Developing Apps for IOS 如何使用docker部署前端博客 Nodejs cluster模块深入探究 WebFrontEndStack 前端技术栈 小工具 wikiHow 什么都可以问 warriorjs Screeps 博客搭建工具 Steam 游戏折扣 SteamDB open game Art PDF转Word转换器 MacWk - mac软件 xclient - mac软件 clustrmaps 站点访问IP地图 小技巧 图床的选择 一千行 MySQL 学习笔记 URLSearchParams 对象用法 Windows下如何查看某个端口被谁占用 Postman 使用方法详解 HTML import(中文翻译) 项目实操 使用Express和MongoDB搭建多人博客","link":"/2020/04/07/%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%20%E6%96%87%E7%AB%A0%E3%80%81%E5%8D%9A%E5%AE%A2%E3%80%81%E8%B5%84%E6%BA%90/"},{"title":"[转]奇妙的CSS之布局与定位","text":"转载自：http://www.cnblogs.com/syfwhu/p/4319236.html 关于布局与定位是Web前端开发里非常基础而又重要的部分。介绍相关知识的文章，很容易就可以找到。虽然，这方面的知识点不是很多，但我们如果不弄清楚，在运用时候往往会出现预料之外的布局，这些“意外”有时候很令人苦恼。下面根据我的学习和编程经验来谈一下这方面的要点。 要想完美的实现自己的布局，那首先一定要把盒模型搞清楚。盒模型由内容区、内边距（padding）、边框（border）和外边距（margin）构成。这些属性值都是可选的，相互之间没有依赖关系，但在具体的布局时会需要设置某些属性。我们平时设置的宽度和高度其实都是内容区的大小，而不是整个元素的大小。详细情况如下： 那么既然了解了盒模型，我们怎么让元素按照我们的意愿布局呢？接下来就来探讨一下这个问题。 其实浏览器在页面上摆放HTML元素时，它是采用文档流（flow）来实现的。就像瀑布一样从最上面的元素开始，自上而下进行元素显示，遇到块元素自动换行，默认每个块元素会占浏览器窗口的整个宽度。而内联元素会在水平方向上自左向右显示，总体上从左上方流向右下方，在垂直方向上扩展外围元素。 边距折叠 关于流和盒模型我们还需要了解，浏览器在并排显示两个内联元素时，这两个原时间的外边距是不会重合的，二者边框之间的距离是两者外边距之和；当两个块元素上下放置时，它们挨着的外边距会折叠起来，显示出来的外边距就是二者外边距里的最大值。当元素嵌套时，也会发生外边距折叠问题，其只会合并上边距和下边距，左右外边距并不合并。需要注意的是，如果外面的元素有一个边框，那么这两个元素的外边距就不会碰到一起，也就不可能发生折叠。我们只需要记住：只要两个垂直边距碰到一起，它们就会折叠，即使是嵌套起来的也不例外。浮动元素由于已经不在文档流之中，它们的外边距是不会折叠的。 关于浮动我们需要了解，浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。要想使元素浮动，必须为元素设置一个宽度（width）。虽然浮动元素不是文档流之中，但是它浮动后所处的位置依然是在浮动之前的水平方向上。由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样，下面的元素填补原来的位置。有些元素会在浮动元素的下方，但是这些元素的内容并不一定会被浮动的元素所遮盖，对内联元素进行定位时，这些元素会考虑浮动元素的边界，会围绕着浮动元素放置。也可以把浮动元素想象成是被块元素忽略的元素，而内联元素会关注浮动元素的。 CSS 有三种基本的定位机制：普通流、浮动和绝对定位。除非专门指定，否则所有框都在普通流中定位。也就是说，普通流中的元素的位置由元素在 (X)HTML 中的位置决定。 position 属性 static：元素框正常生成。块级元素生成一个矩形框，作为文档流的一部分，行内元素则会创建一个或多个行框，置于其父元素中。如果不为元素指定定位方式，会采用默认的静态定位方式。如果是静态定位，那么元素就放在正常的文档流中，由浏览器完全决定元素的摆放。虽然你可以用float来浮动元素，但最终还是由浏览器决定元素的最终放置。 relative：元素框偏移某个距离。相对定位的元素会正常的流入页面，不过在页面上要进行偏移。 absolute：元素框从文档流完全删除，并相对于其包含块定位。包含块可能是文档中的另一个元素或者是初始包含块。元素原先在正常文档流中所占的空间会关闭，就好像元素原来不存在一样。元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 绝对定位（absolute），虽然也是从文档流中删除，但它与浮动是不同的，它不会再和原来位置保持水平，而是由top,right,bottom,left等属性值确定，这些值都是相对于其父元素的。而且流中的元素无论是块元素还是内联元素都不再关注绝对定位的元素，它们完全不知道页面上有绝对定位元素的存在。所以在布局时为了不被绝对定位元素遮盖文档流中的元素，最好给下面的元素设置恰当的外边距（margin）。绝对定位元素还有一个很意思的特性，那就是可以分层放置，可以用z-index属性来分层放置元素，这会指定它在一个虚拟z轴（垂直于页面）上的位置，而且越靠近你的元素z-index值越大。当然z-index属性并不是绝对定位所专属的，相对定位和固定定位的元素也有这个属性。绝对定位时并不需要对元素设置宽度(width)，如果不指定宽度，则块元素会默认的占浏览器的整个宽度（包含margin-left和margin-right，并不仅仅是内容宽度width）。 fixed：元素框的表现类似于将 position 设置为 absolute，不过其包含块是视窗本身。也就是说，固定定位会把元素放在相对于浏览器窗口的一个位置上（不是相对于页面，html），固定定位的元素是不会随页面滚动而移动的。 上面已经介绍了布局定位需要用到的知识，那么我们就可以按照自己的需要实现布局啦！使用HTML和CSS建立布局有很多种可以使用的方法，比如浮动布局、凝胶布局、绝对布局和表格显示布局等。要想掌握布局与定位还需要自己多多实践，只有在编程中才能获得提高。先写这么多吧，以后有时间的话再把实例补充进来……","link":"/2019/05/10/%E8%BD%AC-%E5%A5%87%E5%A6%99%E7%9A%84CSS%E4%B9%8B%E5%B8%83%E5%B1%80%E4%B8%8E%E5%AE%9A%E4%BD%8D/"},{"title":"ES6学习笔记","text":"记录ES6学习过程中的一些内容 部分摘自ECMAScript 6 入门 let和constletES6 新增了let，用来声明变量。它的用法类似于var，但声明的变量只在let命令所在的代码块内有效。 1234567{ let a = 10; var b = 1;}a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 面试题： let和var的区别是什么？ let声明的变量只在let命令所在的代码块内有效, 而且有暂时性死区的约束 1234567891011121314题目1：var a = 99; // 全局变量af(); // f是函数，虽然定义在调用的后面，但是函数声明会提升到作用域的顶部。 console.log(a); // a=&gt;99, 此时是全局变量的afunction f() { console.log(a); // 当前的a变量是下面变量a声明提升后，默认值undefined var a = 10; console.log(a); // a =&gt; 10}// 输出结果：undefined1099 ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以{}限定不了var声明变量的访问范围。 1234{ var i = 9;} console.log(i); // 9 ES6 1234{ let i = 9; //只在所在的代码块有效} console.log(i); // Uncaught ReferenceError: i is not defined 又一个面试题： 12345678for (var i = 0; i &lt;10; i++) { setTimeout(function() { // 同步注册回调函数到 异步的 宏任务队列。 console.log(i); // 执行此代码时，同步代码for循环已经执行完成 }, 0);}// 输出结果10 共10个// 这里面的知识点： JS的事件循环机制，setTimeout的机制等 将var改成let 12345678// i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰。for (let i = 0; i &lt; 10; i++) { setTimeout(function() { console.log(i); // i 是循环体内局部作用域，不受外界影响。 }, 0);}// 输出结果：0 1 2 3 4 5 6 7 8 9 用let声明的变量，不存在变量提升 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 let不允许在相同作用域内，重复声明同一个变量。 ES6的数组去重 ES6的数组去重： 123let arr = [1,1,'1','1',null,null,undefined,undefined,NaN,NaN];console.log(new Set(arr));let newArr = Array.from(new Set(arr)); //或者 [...new Set(arr)] ES5 1234567891011var array = [1, '1', 1, 2, 3, 2, 4];var tmpObj = {};var result = [];array.forEach(function(a) { var key = (typeof a) + a; if (!tmpObj[key]) { tmpObj[key] = true; result.push(a); }});console.log(result); // =&gt; [1, &quot;1&quot;, 2, 3, 4] const const声明一个只读的常量。一旦声明，常量的值就不能改变. 这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 const声明的常量，也与let一样不可重复声明。 const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动 对于简单类型的数据（数值、字符串、布尔值），值保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 块级作用域let实际上为 JavaScript 新增了块级作用域。ES6 允许块级作用域的任意嵌套。 1234{{{{ {let insane = 'Hello World'} console.log(insane); // 报错}}}}; 上面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。第四层作用域无法读取第五层作用域的内部变量。 内层作用域可以定义外层作用域的同名变量。 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了 块级作用域与函数声明ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 1234567891011// 情况一if (true) { function f() {}}// 情况二try { function f() {}} catch(e) { // ...} 上面两种函数声明，根据 ES5 的规定都是非法的。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 变量的解构赋值数组的解构赋值基本用法 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 let a = 1; let b = 2; let c = 3; ES6 允许写成下面这样。 let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上,这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值. 更多例子： 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // &quot;a&quot;y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1let [foo] = 1; //false; NaN; undefined; null; {}; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（{}）。 对于 Set 结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set(['a', 'b', 'c']);x // &quot;a&quot; 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 默认值 解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 参考： null和undefined与NaN 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 对象的解构赋值简介解构不仅可以用于数组，还可以用于对象。 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let { bar, foo } = { foo: 'aaa', bar: 'bbb' };foo // &quot;aaa&quot;bar // &quot;bbb&quot;let { baz } = { foo: 'aaa', bar: 'bbb' };baz // 无同名属性 undefined 如果解构失败，变量的值等于undefined。 如果变量名与属性名不一致，必须写成下面这样。 1234567let { foo: baz } = { foo: 'aaa', bar: 'bbb' };baz // &quot;aaa&quot;let obj = { first: 'hello', last: 'world' };let { first: f, last: l } = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写 1let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' }; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let { foo: baz } = { foo: 'aaa', bar: 'bbb' };baz // &quot;aaa&quot;foo // error: foo is not defined 上面代码中，foo是匹配的模式(json对象中的键)，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 默认值对象的解构也可以指定默认值。 123456789101112131415var {x = 3} = {};x // 3var {x, y = 5} = {x: 1};x // 1y // 5var {x: y = 3} = {};y // 3var {x: y = 3} = {x: 5};y // 5var { message: msg = 'Something went wrong' } = {};msg // &quot;Something went wrong&quot; 默认值生效的条件是，对象的属性值严格等于undefined。 12345var {x = 3} = {x: undefined};x // 3var {x = 3} = {x: null};x // null //属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let {0 : first, [arr.length - 1] : last} = arr; //方括号这种写法，属于“属性名表达式”first // 1last // 3 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456789const [a, b, c, d, e] = 'hello';a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot;let {length : len} = 'hello'; //类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let {toString: s} = 123;s === Number.prototype.toString // truelet {toString: s} = true;s === Boolean.prototype.toString // true 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 12let { prop: x } = undefined; // TypeErrorlet { prop: y } = null; // TypeError 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确({ p: (d) } = {}); // 正确[(parseInt.prop)] = [3]; // 正确 字符串字符的 Unicode 表示法ES6 加强了对 Unicode 的支持，允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 但是，这种表示法只限于码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 字符串的遍历器接口ES6 为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 参考资料： MDN模板字符串 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = &quot;Bob&quot;, time = &quot;today&quot;;`Hello ${name}, how are you ${time}?` //模板字符串中嵌入变量，需要将变量名写在${}之中。 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 如果你不想要这个换行，可以使用trim方法消除它。 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 模板字符串之中还能调用函数。 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。 由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。 模板字符串甚至还能嵌套。 如果需要引用模板字符串本身，在需要时执行，可以写成函数。 12let func = (name) =&gt; `Hello ${name}!`;func('Jack') // &quot;Hello Jack!&quot; 新增方法String-raw)()ES6 还为原生的 String 对象，提供了一个raw()方法。该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。 123456String.raw`Hi\\n${2+3}!`;// 返回 &quot;Hi\\\\n5!&quot;String.raw`Hi\\u000A!`;// 返回 &quot;Hi\\\\u000A!&quot; 如果原字符串的斜杠已经转义，那么String.raw()会进行再次转义。 12String.raw`Hi\\\\n`// 返回 &quot;Hi\\\\\\\\n&quot; String.raw()方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 实例方法：includes(), startsWith(), endsWith()JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 这三个方法都支持第二个参数，表示开始搜索的位置。 12345let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。","link":"/2019/05/06/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"2020&#x2F;11&#x2F;16 纪事","text":"早晨早8点 闹钟响了，但是没有起床，9点起床 9点半出门 早餐是肠粉，本来要寄东西给毛哥，但是怕迟到 所以打算晚上寄。 10点到公司，业务业务业务。。。 中午妈妈发消息说爸爸的腰伤犯了，躺在床上起不来，三节腰椎间盘突出，在家休养，妈妈请假照顾。发来视频电话，但是随后挂断了。12点10分，我去消防通道回拨，接通，爸爸在沙发躺着，妈妈在沙发坐着。没有很紧张的神情，见我来电很高兴，问了一下情况，叮嘱我少吃外卖，表示收到后告诉他们晚点再回拨给他们。没有想象中那么严重，暂时松了一口气。沙县的中午饭，1点，午休。。很吵，同事在打csgo，睡到1点半醒了，睡的很难受。到1点50打起精神。上班，业务业务业务。。。 晚上 6点15左右下班，一起回家。 6点34取了快递，健身环大冒险和PONY的橘色高帮，PONY送的短袖是女装，hhh好吧。 收拾一下出门吃晚饭，在楼下肠粉店吃牛丸面，顺便给毛哥寄回马里奥派对。 回家是7点10分，给爸爸妈妈视频。爸爸已经坐起来了，看起来状态还可以，闲聊，闲聊。 8点10分，开始试健身换大冒险，慢跑、深蹲、抬腿、拉扯普拉提环。 8点50分，结束，第一关boss没有打完，有点虚，还是要加强锻炼。 打开炉石，下了一把棋，选的乔治，拿了第五，不升不降。 9点20分，洗澡。 9点45，洗衣服，烧开水喝。 9点56分，开始写这篇。 20点22分，写完。","link":"/2010/11/16/2020-11-16-%E7%BA%AA%E4%BA%8B/"}],"tags":[{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"javaScript","slug":"javaScript","link":"/tags/javaScript/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"java8","slug":"java8","link":"/tags/java8/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"lodash","slug":"lodash","link":"/tags/lodash/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"闲聊","slug":"闲聊","link":"/tags/%E9%97%B2%E8%81%8A/"},{"name":"脚本算法","slug":"脚本算法","link":"/tags/%E8%84%9A%E6%9C%AC%E7%AE%97%E6%B3%95/"},{"name":"momentJS","slug":"momentJS","link":"/tags/momentJS/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"MySQL&#x2F;Orcale","slug":"MySQL-Orcale","link":"/tags/MySQL-Orcale/"},{"name":"事务","slug":"事务","link":"/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"深拷贝","slug":"深拷贝","link":"/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"cookie&#x2F;session","slug":"cookie-session","link":"/tags/cookie-session/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"website","slug":"website","link":"/tags/website/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"闭包","slug":"闭包","link":"/tags/%E9%97%AD%E5%8C%85/"},{"name":"纪事","slug":"纪事","link":"/tags/%E7%BA%AA%E4%BA%8B/"}],"categories":[]}